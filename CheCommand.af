~~ {
~~ FOR AUTO-COMPLETION ASSISTANCE: testvar getvar setvar touchvar clearallvars clearvar getcharintprop getchardoubleprop getcharquadprop getcharboolprop getcharstringprop getisspellknown getcancastspell_hunt getcancastspell_buff getcharvital_base getcharvital_current getcharvital_buffedmax getcharskill_traininglevel getcharskill_base getcharskill_buffed getplayerlandcell getplayercoordinates coordinategetns coordinategetwe coordinategetz coordinatetostring coordinateparse coordinatedistancewithz coordinatedistanceflat wobjectgetphysicscoordinates wobjectgetname wobjectgetobjectclass wobjectgettemplatetype wobjectgetisdooropen wobjectfindnearestmonster wobjectfindnearestdoor wobjectfindnearestbyobjectclass wobjectfindininventorybytemplatetype wobjectfindininventorybyname wobjectfindininventorybynamerx wobjectgetselection wobjectgetplayer wobjectfindnearestbynameandobjectclass actiontryselect actiontryuseitem actiontryapplyitem actiontrygiveitem actiontryequipanywand actiontrycastbyid actiontrycastbyidontarget chatbox chatboxpaste statushud statushudcolored uigetcontrol uisetlabel isfalse istrue iif randint cstr strlen getobjectinternaltype cstrf stopwatchcreate stopwatchstart stopwatchstop stopwatchelapsedseconds cnumber floor ceiling round abs getworldname getitemcountininventorybyname getheading getitemcountininventorybynamerx getheadingto actiontrygiveprofile vitae getfellowshipstatus getfellowshipname getfellowshipisopen getfellowshipisleader getfellowshipleaderid getfellowshipcanrecruit getfellowid getfellowshipcount getfellowshiplocked getfellowname getfellowshipisfull sin cos tan sqrt asin acos atan atan2 sinh cosh tanh vtsetmetastate getregexmatch echo chr ord wobjectgetid wobjectgethealth wobjectfindbyid wobjectgetintprop wobjectfindnearestbytemplatetype wobjectgetopencontainer testquestflag getquestktprogress isrefreshingquests getquestktrequired getqueststatus getisday getgamehour getgamehourname getisnight getgameday getgameticks getminutesuntilday getgamemonth getgamemonthname getminutesuntilnight getgameyear uisetvisible uiviewvisible uiviewexists getgvar touchgvar getpvar touchpvar setgvar cleargvar setpvar clearpvar testgvar clearallgvars testpvar clearallpvars dictgetitem dictcreate dicthaskey dictadditem dictkeys dictremovekey dictvalues dictclear dictsize dictcopy listgetitem listpop listcreate listcontains listremove listadd listindexof listremoveat listinsert listlastindexof listclear listcopy listcount listreverse

~~
~~ File auto-generated by metaf, a program created by Eskarina of Morningthaw/Coldeve.
~~		Get metaf here: https://github.com/JJEII/metaf/
~~
~~ All recognized structural designators:
~~		STATE:				DO:
~~		IF:					NAV:
~~
~~ All recognized CONDITION (IF:) operation keywords:
~~		Never				NavEmpty			MobsInDist_Priority		Not
~~		Always				Death				NeedToBuff				PSecsInStateGE
~~		All					VendorOpen			NoMobsInDist			SecsOnSpellGE
~~		Any					VendorClosed		BlockE					BuPercentGE
~~		ChatMatch			ItemCountLE			CellE					DistToRteGE
~~		MainSlotsLE			ItemCountGE			IntoPortal				Expr
~~		SecsInStateGE		MobsInDist_Name		ExitPortal				ChatCapture
~~
~~ All recognized ACTION (DO:) operation keywords:
~~		None				EmbedNav			ChatExpr				SetOpt
~~		SetState			CallState			SetWatchdog				CreateView
~~		Chat				Return				ClearWatchdog			DestroyView
~~		DoAll				DoExpr				GetOpt					DestroyAllViews
~~
~~ All recognized NAV types:
~~		circular			follow
~~		linear				once
~~
~~ All recognized NAV NODE types:
~~		flw					vnd
~~		pnt					ptl
~~		rcl					tlk
~~		pau					chk
~~		cht					jmp
~~		prt (deprecated in VTank)
~~ }


STATE: {Default} ~~ {

	~~ Utility Belt Options
	IF: Expr {uboptget[`VTank.PatchExpressionEngine`]==false}
		DO: DoExpr {uboptset[`VTank.PatchExpressionEngine`, true]}

	IF: Expr {uboptget[`Jumper.ThinkComplete`]==false}
		DO: DoExpr {uboptset[`Jumper.ThinkComplete`, true]}

	IF: Expr {uboptget[`Jumper.ThinkFail`]==false}
		DO: DoExpr {uboptset[`Jumper.ThinkFail`, true]}

	IF: Expr {uboptget[`AutoVendor.Think`]==false}
		DO: DoExpr {uboptset[`AutoVendor.Think`, true]}


	~~ Constants
	IF: Always
		DO: DoAll

				DoExpr {setvar[NUMBER, 1]}
				DoExpr {setvar[MONSTER, 5]}
				DoExpr {setvar[OBJECT, 7]}
				DoExpr {setvar[PORTAL, 14]}
				DoExpr {setvar[PLAYER, 24]}
				DoExpr {setvar[VENDOR, 25]}
				DoExpr {setvar[CORPSE, 27]}
				DoExpr {setvar[NPC, 37]}
				DoExpr {setvar[FOCI, 38]}

				DoExpr {setvar[STRING_PROP_NAME, 1]}
				DoExpr {setvar[STRING_PROP_DESCRIPTION, 16]}

				DoExpr {setvar[COLOR_DEBUG, 17]}
				DoExpr {setvar[COLOR_INFO, 5]}
				DoExpr {setvar[COLOR_WARN, 31]}
				DoExpr {setvar[COLOR_ERROR, 21]}

				DoExpr {setvar[LEVEL_DEBUG, 10]}
				DoExpr {setvar[LEVEL_INFO, 20]}
				DoExpr {setvar[LEVEL_WARN, 30]}
				DoExpr {setvar[LEVEL_ERROR, 40]}

				DoExpr {setvar[TYPE_NONE, 0]}
				DoExpr {setvar[TYPE_NUMBER, 1]}
				DoExpr {setvar[TYPE_STRING, 3]}
				DoExpr {setvar[TYPE_OBJECT, 7]}

				DoExpr {setvar[CLOSE_BLUE, 15]}

				DoExpr {setvar[CHARACTER_NAME, getcharstringprop[$STRING_PROP_NAME]]}

				DoExpr {setvar[RYNTHID_WEAPONS_PORTAL, 52012]}

	~~ Initialize CC variables
	IF: Always
		DO: DoAll
				DoExpr {setvar[CCVersion, `0.9.0`]}

				DoExpr {setpvar[CCDebug, ifthen[testpvar[CCDebug], `@CCDebug`, `$LEVEL_DEBUG`]]}
				DoExpr {setpvar[CCConfirm, ifthen[testpvar[CCConfirm], `@CCConfirm`, `true`]]}
				DoExpr {setpvar[CCFellowname, ifthen[testpvar[CCFellowname], `@CCFellowname`, `Not Set`]]}
				DoExpr {setpvar[CCCharacterList, ifthen[testpvar[CCCharacterList], `@CCCharacterList`, `listcreate[]`]]}

				DoExpr {setpvar[CCChatCommand, ifthen[testpvar[CCChatCommand], `@CCChatCommand`, `Say`]]}

				~~ Amount of seconds between checking stuck
				DoExpr {setpvar[CCStuckAnnounceDelay, ifthen[testpvar[CCStuckAnnounceDelay], `@CCStuckAnnounceDelay`, `5`]]}

				~~ Maximum amount a character can move to determine stuck
				DoExpr {setpvar[CCStuckThreshold, ifthen[testpvar[CCStuckThreshold], `@CCStuckThreshold`, `1`]]}

				~~ Distance away a character must be to announce stuck
				DoExpr {setpvar[CCStuckDistanceThreshold, ifthen[testpvar[CCStuckDistanceThreshold], `@CCStuckDistanceThreshold`, `20`]]}

				~~ Leader to announce things to. Defaults to first character in @CCCharacterList and will update when follow commands are issued
				DoExpr {setpvar[CCLeader, ifthen[testpvar[CCLeader], `@CCLeader`, `listgetitem[@CCCharacterList, 0]`]]}

				~~ Distance to use the nearest Portal
				DoExpr {setpvar[CCPortalThreshold, ifthen[testpvar[CCPortalThreshold], `@CCPortalThreshold`, `30`]]}

				~~ Distance to use the nearest NPC
				DoExpr {setpvar[CCNPCThreshold, ifthen[testpvar[CCNPCThreshold], `@CCNPCThreshold`, `30`]]}

				~~ Distance the leader needs to be within to leave LeaderCheck
				DoExpr {setpvar[CCLeaderCheckDistance, ifthen[testpvar[CCLeaderCheckDistance], `@CCLeaderCheckDistance`, `60`]]}

				~~ Are vitals on or off
				DoExpr {setpvar[CCVitals, ifthen[testpvar[CCVitals], `@CCVitals`, `true`]]}

				~~ Equip Item for handin
				DoExpr {setpvar[CCEquipOnTurnin, ifthen[testpvar[CCEquipOnTurnin], `@CCEquipOnTurnin`, `false`]]}

				~~ Are the followers staying
				DoExpr {setpvar[CCStay, ifthen[testpvar[CCStay], `@CCStay`, `true`]]}

				~~ Announce VR Blue
				DoExpr {setpvar[CCAnnounceVRBlue, ifthen[testpvar[CCAnnounceVRBlue], `@CCAnnounceVRBlue`, `true`]]}

				~~ Use Rynthid Weapons Portal
				DoExpr {setpvar[CCUseRynthidWeaponsPortal, ifthen[testpvar[CCUseRynthidWeaponsPortal], `@CCUseRynthidWeaponsPortal`, `true`]]}

				~~ Distance to recruit nearby players with `#fellow nearby`
				DoExpr {setpvar[CCFellowNearbyRecruitDistance, ifthen[testpvar[CCFellowNearbyRecruitDistance], `@CCFellowNearbyRecruitDistance`, `30`]]}

				~~ Maximum fellowship size
				DoExpr {setpvar[CCMaxFellowshipSize, ifthen[testpvar[CCMaxFellowshipSize], `@CCMaxFellowshipSize`, `9`]]}

				~~ Use Auto Timers
				DoExpr {setpvar[CCAutoTimers, ifthen[testpvar[CCAutoTimers], `@CCAutoTimers`, `true`]]}

				~~ Metas (UB does not support dictionaries in pvars so using two lists instead)
				DoExpr {setpvar[CCMetaKeys, ifthen[testpvar[CCMetaKeys], `@CCMetaKeys`, `listcreate[]`]]}
				DoExpr {setpvar[CCMetaValues, ifthen[testpvar[CCMetaValues], `@CCMetaValues`, `listcreate[]`]]}

				~~ Profiles (UB does not support dictionaries in pvars so using two lists instead)
				DoExpr {setpvar[CCProfileKeys, ifthen[testpvar[CCProfileKeys], `@CCProfileKeys`, `listcreate[]`]]}
				DoExpr {setpvar[CCProfileValues, ifthen[testpvar[CCProfileValues], `@CCProfileValues`, `listcreate[]`]]}

				~~ Profiles landcells (UB does not support dictionaries in pvars so using two lists instead)
				DoExpr {setpvar[CCProfileLandcellKeys, ifthen[testpvar[CCProfileLandcellKeys], `@CCProfileLandcellKeys`, `listcreate[]`]]}
				DoExpr {setpvar[CCProfileLandcellValues, ifthen[testpvar[CCProfileLandcellValues], `@CCProfileLandcellValues`, `listcreate[]`]]}

				~~ Amount of time to surpress announcing available looting in seconds
				DoExpr {setpvar[CCAnnounceLootingTimeout, ifthen[testpvar[CCAnnounceLootingTimeout], `@CCAnnounceLootingTimeout`, `60`]]}

				~~ Amount of time to surpress announcing available giving in seconds
				DoExpr {setpvar[CCAnnounceGivingTimeout, ifthen[testpvar[CCAnnounceGivingTimeout], `@CCAnnounceGivingTimeout`, `60`]]}

				~~ Distance to an NPC to announce auto giving
				DoExpr {setpvar[CCAnnounceThreshold, ifthen[testpvar[CCAnnounceThreshold], `@CCAnnounceThreshold`, `5`]]}

				~~ Spell to use to check time remaining on buffs. This cannot be a spell that is in your suit. Only self casted spells will give the correct time remaining.
				DoExpr {setpvar[CCCheckBuffsSpell, ifthen[testpvar[CCCheckBuffsSpell], `@CCCheckBuffsSpell`, `Jumping Mastery Self`]]}

				~~ Amount of time left in buffs duration to warn about low buffs. Defaults to 30 minutes.
				DoExpr {setpvar[CCWarnBuffsDuration, ifthen[testpvar[CCWarnBuffsDuration], `@CCWarnBuffsDuration`, `1800`]]}

				~~ Amount of time to surpress announcing when buffs are low
				DoExpr {setpvar[CCAnnounceBuffsTimeout, ifthen[testpvar[CCAnnounceBuffsTimeout], `@CCAnnounceBuffsTimeout`, `300`]]}

				~~ Amount of luminance to warn when turning in
				DoExpr {setpvar[CCWarnLuminance, ifthen[testpvar[CCWarnLuminance], `@CCWarnLuminance`, `1300000`]]}

				~~ Automatically start a timer for Rynthid Weapons wave one
				DoExpr {setpvar[CCTimerWeapons, ifthen[testpvar[CCTimerWeapons], `@CCTimerWeapons`, `true`]]}

				~~ Message to send at the end of automatic Rynthid Weapons timer
				DoExpr {setpvar[CCTimerWeaponsMsg, ifthen[testpvar[CCTimerWeaponsMsg], `@CCTimerWeaponsMsg`, `false`]]}

				~~ Automatically start a timer for VR Speed Runs
				DoExpr {setpvar[CCTimerVR, ifthen[testpvar[CCTimerVR], `@CCTimerVR`, `true`]]}

				~~ Message to send at the end of automatic VR Speed Runs timer
				DoExpr {setpvar[CCTimerVRMsg, ifthen[testpvar[CCTimerVRMsg], `@CCTimerVRMsg`, `false`]]}

				~~ Distance to use nearest trash npc
				DoExpr {setpvar[CCTrashDistance, ifthen[testpvar[CCTrashDistance], `@CCTrashDistance`, `15`]]}

				~~ Distance away from `#jump on me` issuer to get when considering on them
				DoExpr {setpvar[CCOnMeThreshold, ifthen[testpvar[CCOnMeThreshold], `@CCOnMeThreshold`, `0.1`]]}

				~~ If the character should jump when looting
				DoExpr {setpvar[CCJumpLoot, ifthen[testpvar[CCJumpLoot], `@CCJumpLoot`, `false`]]}

				~~ Whether the Actions view is open or closed
				DoExpr {setpvar[CCViewsActions, ifthen[testpvar[CCViewsActions], `@CCViewsActions`, `false`]]}

				~~ Whether the Jump view is open or closed
				DoExpr {setpvar[CCViewsJump, ifthen[testpvar[CCViewsJump], `@CCViewsJump`, `false`]]}


				DoExpr {setvar[AutoTimers, listcreate[]]}
				DoExpr {listadd[$AutoTimers, listcreate[11, 00, 00, `AM`, listcreate[`CheCommandNavRecomp`, `CheCommandNavChair`]]]}

				~~ DoExpr {listadd[$AutoTimers, listcreate[2, 20, 00, `AM`, listcreate[`CheCommandNavRecomp`]]]}
				~~ DoExpr {listadd[$AutoTimers, listcreate[2, 21, 00, `AM`, listcreate[`CheCommandNavRecomp`]]]}
				~~ DoExpr {listadd[$AutoTimers, listcreate[2, 22, 00, `AM`, listcreate[`CheCommandNavRecomp`]]]}
				~~ DoExpr {listadd[$AutoTimers, listcreate[2, 23, 00, `AM`, listcreate[`CheCommandNavRecomp`]]]}
				~~ DoExpr {listadd[$AutoTimers, listcreate[2, 24, 00, `AM`, listcreate[`CheCommandNavRecomp`]]]}
				~~ DoExpr {listadd[$AutoTimers, listcreate[2, 25, 00, `AM`, listcreate[`CheCommandNavRecomp`]]]}
				~~ DoExpr {listadd[$AutoTimers, listcreate[2, 26, 00, `AM`, listcreate[`CheCommandNavRecomp`]]]}
				~~ DoExpr {listadd[$AutoTimers, listcreate[2, 27, 00, `AM`, listcreate[`CheCommandNavRecomp`]]]}
				~~ DoExpr {listadd[$AutoTimers, listcreate[2, 28, 00, `AM`, listcreate[`CheCommandNavRecomp`]]]}
				~~ DoExpr {listadd[$AutoTimers, listcreate[2, 29, 00, `AM`, listcreate[`CheCommandNavRecomp`]]]}

				~~ Nav Routes
				~~ Keys are landcells in hexidecimal format, values are the name of the nav file without the file extension
				DoExpr {setvar[CCRoutes, dictcreate[]]}
				DoExpr {dictadditem[$CCRoutes, `59540817`, `CC-Catacombs of Torment`]}
				DoExpr {dictadditem[$CCRoutes, `002C029C`, `CC-Forgotten Chasm`]}
				DoExpr {dictadditem[$CCRoutes, `472D0107`, `CC-Massilor's Crypt`]}
				DoExpr {dictadditem[$CCRoutes, `00060100`, `CC-Western Power Forge`]}
				DoExpr {dictadditem[$CCRoutes, `002E02D1`, `CC-Feeding Tube`]}
				DoExpr {dictadditem[$CCRoutes, `5879052B`, `CC-Path of Rage`]}
				DoExpr {dictadditem[$CCRoutes, `5E450372`, `CC-Black Death Catacombs`]}
				DoExpr {dictadditem[$CCRoutes, `5652038A`, `CC-Halt Dericost Mnemosynes`]}
				DoExpr {dictadditem[$CCRoutes, `56520245`, `CC-Halt Dericost`]}
				DoExpr {dictadditem[$CCRoutes, `79E9033A`, `CC-Bloodstone Investigation 3`]}

	~~ Setup Auto Giving
	IF: Always
		DO: DoAll
				DoExpr {setvar[AUTOGIVE_PROFILE, dictcreate[]]}

				~~ Sundering Quests
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Liora Fenn`, `Bitter Tongue's Head`]} ~~ Drudge Hideout Infiltration
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Emissary of Asheron`, listcreate[`Virindi Observer's Message Shard`, `Dark Apostate Shard`, `Engorged Bloodstone Shards`, `Virindi Armorer's Message Shard`, `Dericost Gem of Luminance`, `Shard of the Apostate Grand Director's Broken Mask`, `Apostate Grand Director's Mask`]]} ~~ Return to Frore, Empyrean Rescue, Apostate Finale
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Zervakarix`, `Viridian Rise Pocket Watch`]} ~~ Return to Frore

				~~ Legendary Quests
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Uber P`, `Letter from Mouf`]} ~~ Rescuing Mouf P
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Mr. P`, listcreate[`Letter from Mouf and Uber P`, `Pet Mouf Igloo`]]} ~~ Rescuing Mouf P
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Kraytuss Nallah`, `Bone Fragment from Shikken Moriyaki`]} ~~ Serpent Burial Grounds
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Collector Golem`, listcreate[`Glowing Statue Shard`, `Essence of the Sundered`, `Empowered Empyrean Robe`]]} ~~ Saving Asheron
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Fanzen San the Translator`, listcreate[`Complete Page of Lost Lore`, `Orders for Zrikux`]]} ~~ Lost Lore, Falacot Depot
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Popkin of the Gate`, `The Story of the Lost Sisters`]} ~~ Lost Lore
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Ruby Annex`, `Shroud of Bloodlust`]} ~~ Shroud of Emotion
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Amethyst Annex`, `Shroud of Spite`]} ~~ Shroud of Emotion
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Jade Annex`, `Shroud of Envy`]} ~~ Shroud of Emotion
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Sapphire Annex`, `Shroud of Apathy`]} ~~ Shroud of Emotion
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Rinne Gorber`, listcreate[`Spirit Crystal`, `Spirited Bloodlust Guard`, `Spirited Spite Guard`, `Spirited Envy Guard`, `Spirited Apathy Guard`]]} ~~ Shroud of Emotion
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Lady Daenerah`, `Sealed Tome`]} ~~ Shroud of Emotion
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Mareeno Donn`, `First Lieutenant's Insignia.`]} ~~ Hoshino Infiltration
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Fahneph`, `Ancient Falatacot Symbol`]} ~~ Foundry of Izexi
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Mhoire Soldier`, `Book`]} ~~ Geraine's Study
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Commander Presk`, `Sealed Scroll for Commander Presk`]} ~~ Lugian Assault
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Raksaa`, listcreate[`Sealed Scroll for Raksaa`, `Casting Stone`]]} ~~ Lugian Assault
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Aun Ol'tra`, listcreate[`Crimson Scarab`, `Purified Crimson Scarab`]]} ~~ End of Days
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Morgethais`, `Shard of the Curator of Torment's Mask`]} ~~ Defeating the Curator of Torment
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Spirit of Bist'elle`, `Mirror Shard`]} ~~ Hoshino Must Die
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Mortified Soldier`, `Torn Note`]} ~~ Gurog Creation
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Fayza`, listcreate[`Journal of a Soldier`, `Energy Infused Rock`]]} ~~ Gurog Creation, Deewains
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Kuyiza bint Zayi the Translator`, listcreate[`Carefully rolled scroll`, `Large Tome`]]} ~~ Bloodstone Investigation
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Sir Donovan`, listcreate[`Bloodstone Report`, `Research Notes`, `Shattered Master Bloodstone Shard`, `Delicate Bloodstone Wand`, `Sturdy Bloodstone Wand`]]} ~~ Bloodstone Investigation
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Virindi Delegate`, listcreate[`Olthoi Hive Queen Carapace`, `Virindi Sentinel's Message Shard`, `Splinter of Hatred`, `Splinter of Anger`, `Splinter of Misery`]]} ~~ Hive Queen Assault, Dream Reaver Investigation
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Mhoire Lieutenant`, `Geraine's Tome \\(1\\)`]} ~~ Geraine's Hosts
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Darviss`, `Spectral Nanjou Master's Sword`]} ~~ Ninja Academy
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Kinchou`, `Coded Tanada Scroll`]} ~~ Tanada Intercept
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Kousha`, `Tanada Neophyte's Mask`]} ~~ Tanada Slaughter
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Shorikan`, `Spectral Nanjou Zaikan's Sword`]} ~~ Nanjou Stockade
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `El'Yst Maggann`, `Idol of the Recluse`]} ~~ Four Corners
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Aetherium Ore`, `Tainted Aetherium Oil`]} ~~ Rynthid Foundry
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Kaltus`, `Seed of Essence`]} ~~ Harvesting the Bulb of Mornings
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Calitoth`, listcreate[`Legendary Seed of Mornings`, `Legendary Seed of Harvests`, `Legendary Seed of Twilight`]]} ~~ Harvesting the Bulb of Mornings
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Adrenkus`, `Seed of Essence`]} ~~ Harvesting the Bulb of Mornings
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Sanctum Guardian Spirit`, `Pulsating Spirit-trap Gem`]} ~~ Harvesting the Bulb of Twilight
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Norus`, `Seed of Essence`]} ~~ Harvesting the Bulb of Twilight
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Rynthid Crystal Access Device`, `Focused Splinter of Hatred`]} ~~
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Ancient Altar`, `Ancient Skull and Bones`]} ~~
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Mu-miyah Device`, `Red Destabilizing Crystal`]} ~~ Slave Master

				~~ Luminance Quests
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Aun Aemaua`, `Claw of the Hopeslayer`]} ~~ Ithaenc Quiddity Seed Quest
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Apostate Aetherium Deposit`, `Aetheric Resonator`]} ~~ Nexus Crawl
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Diyas al-Yat`, `Apostate Message Shard`]} ~~ Uncovering the Renegades
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Aruq ibn Balthar`, `Apostate Orders`]} ~~ Uncovering the Renegades
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Neelic`, `Translated Orders for Zrikux`]} ~~ Falacot Depot
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Omarah`, `Essence of Dravann`]} ~~ Virindi Rescue
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Jilna Fullgood`, `Prodigal Tusker's Token`]} ~~ Aerbax's Prodigal Tusker

				~~ Random
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Fiun Rehlyun`, `Insatiable Eater Jaw`]} ~~ Blank Aug Gem
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Mana Siphon`, `Unstable Mana Stone`]} ~~ Society
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Kervim'telek`, listcreate[`Essence of Norshuntyr`, `Essence of Night Brier`, `Essence of Wind Fury`, `Essence of Zerzelikyr`]]} ~~ Virindian Rise
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `The Deep`, `Altered Dark Remoran Fin`]} ~~ Society
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Lord Kresovus`, `Sigil of Linvak Tukal`]} ~~ Aerbax's Prodigal Lugian
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Master of the Gauntlet`, listcreate[`Holcha's Head`, `Gromnus Eye`]]} ~~ Gauntlet
				DoExpr {dictadditem[$AUTOGIVE_PROFILE, `Ayesha of the Radiant Blood`, `Corrupted Mana Shard`]} ~~ Radiant Blood Society Flagging

	~~ Setup Auto Looting
	IF: Always
		DO: DoAll
				DoExpr {setvar[AUTO_LOOT_CORPSES, dictcreate[]]}

				~~ Sundering Quests
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Bitter Tongue`, `Bitter Tongue's Head`]} ~~ Drudge Hideout Infiltration
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Ler Rhan`, `Dericost Gem of Luminance`]} ~~ Uber Nexus
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Nexus Crystal`, `Nexus Core Gem`]} ~~ Uber Nexus
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Fidisa the Agile`, `Shattered Key`]} ~~ Uber Frore
				~~ DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Virindi Observer`, `Virindi Observer's Message Shard`]} ~~ Uber Frore
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of The Great Work`, `Crystal Device`]} ~~ Uber Frore

				~~ Legendary Quests
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Izexi`, `Ancient Falatacot Symbol`]} ~~ Foundry of Izexi Quest
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Shikken Moriyaki`, `Bone Fragment from Shikken Moriyaki`]} ~~ Serpent Burial Grounds
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Falatacot Blood Prophetess`, `Torn Strip of Parchment`]} ~~ Serpent Burial Grounds
				~~ DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Gurog Minion`, `Torn Note`]} ~~ Gurog Creation
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Virindi Sentinel`, `Virindi Sentinel's Message Shard`]} ~~ Dream Reaver Investigation
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Lord Winstead`, `Sealed Tome`]} ~~ Halt Dericost Ritual
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Bah'Ktar`, `Crimson Scarab`]} ~~
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Kul Bronzegear`, `Legendary Key`]} ~~ Purging the Corruption
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Lord Kastellar`, `Large Tome`]} ~~ Bloodstone Investigation
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Treasure of Master Bloodstone`, `Shattered Master Bloodstone Shard`]} ~~ Bloodstone Investigation
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Geraine`, `Book`]} ~~ Geraine's Study
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Materialized Hoshino Kei`, `Mirror Shard`]} ~~ Hoshino Must Die
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Spectral Nanjou Master`, `Spectral Nanjou Master's Sword`]} ~~ Ninja Academy
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Tanada Nanjou Jogensha`, `Coded Tanada Scroll`]} ~~ Tanada Intercept and Slaughter
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Spectral Nanjou Zaikan`, `Spectral Nanjou Zaikan's Sword`]} ~~ Nanjou Stockade
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Treasure of Apparition of Bloodlust`, `Shroud of Bloodlust`]} ~~ Shroud of Emotion
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Treasure of Apparition of Apathy`, `Shroud of Apathy`]} ~~ Shroud of Emotion
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Treasure of Apparition of Envy`, `Shroud of Envy`]} ~~ Shroud of Emotion
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Treasure of Apparition of Spite`, `Shroud of Spite`]} ~~ Shroud of Emotion
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Ronin Hirachi`, `Ancient Skull`]} ~~
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Ronin Shimakawa`, `Ancient Arm Bone`]} ~~
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Ronin Ginmura`, `Shaped Arm Bone`]} ~~
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of First Lieutenant`, `First Lieutenant's Insignia.`]} ~~
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Shade of Lord Rytheran`, `Rytheran's Jeweled Ring`]} ~~
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Mu-miyah Soothsayer`, `Yellow Destabilizing Crystal`]} ~~ Slave Master
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Mu-miyah Channeller`, `Red Destabilizing Crystal`]} ~~ Slave Master


				~~ Luminance Quests
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Zrikux`, `Orders for Zrikux`]} ~~ Falacot Depot
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Dravann`, `Essence of Dravann`]} ~~ Virindi Rescue
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Apostate Master`, `Apostate Message Shard`]} ~~ Uncovering the Renegades
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Dark Bobo`, `Prodigal Tusker's Token`]} ~~ Aerbax Prodigal Tusker
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Apostate Grand Director`, `Shard of the Apostate Grand Director's Broken Mask`]} ~~ Apostate Finale


				~~ Random
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Battle Lord Gregor`, `Battle Lord Gregor's Mnemosyne`]} ~~ Luminance Flagging
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Shadow Kresovus`, `Sigil of Linvak Tukal`]} ~~ Aerbax's Prodigal Lugian
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Holcha`, `Holcha's Head`]} ~~ Holcha
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Gromnus Champion`, `Gromnus Eye`]} ~~ Gromnus Champion
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Zerzelikyr`, `Essence of Zerzelikyr`]} ~~ VR Boss
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of NightBrier`, `Essence of NightBrier`]} ~~ VR Boss
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Wind Fury`, `Essence of Wind Fury`]} ~~ VR Boss
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Norshuntyr`, `Essence of Norshuntyr`]} ~~ VR Boss
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Paradox-touched Olthoi Queen`, `Carapace Shard`]} ~~ Paradox-touched Olthoi Queen
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Forge Golem`, `Forge Vault Key`]} ~~
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Gladiator Diemos`, `Gladiator Diemos Token`]} ~~
				DoExpr {dictadditem[$AUTO_LOOT_CORPSES, `Corpse of Sir Bellas`, `Blank Augmentation Gem`]} ~~

	~~ Setup Auto Trash
	IF: Always
		DO: DoAll
				DoExpr {setvar[AUTO_TRASH_ITEMS, listcreate[]]}
				DoExpr {listadd[$AUTO_TRASH_ITEMS, `Apostate Orders`]}
				DoExpr {listadd[$AUTO_TRASH_ITEMS, `Torn Parchment`]} ~~ Geraine's Library
				DoExpr {listadd[$AUTO_TRASH_ITEMS, `Stone Tablet`]} ~~ Geraine's Library
				DoExpr {listadd[$AUTO_TRASH_ITEMS, `Powdered Chorizite Pea`]} ~~ Aerbax's Prodigal Lugian
				DoExpr {listadd[$AUTO_TRASH_ITEMS, `Translated Orders for Zrikux`]} ~~ Falacot Depot
				DoExpr {listadd[$AUTO_TRASH_ITEMS, `Forging Gloves`]} ~~ Falacot Depot
				DoExpr {listadd[$AUTO_TRASH_ITEMS, `Translated Message Shard`]} ~~ Dream Reaver Investigation
				DoExpr {listadd[$AUTO_TRASH_ITEMS, `Complete Dispatch`]} ~~ Shard of the Herald
				DoExpr {listadd[$AUTO_TRASH_ITEMS, `Empowered Robe of the Perfect Light`]} ~~ Halt Dericost
				DoExpr {listadd[$AUTO_TRASH_ITEMS, `Coral Shield`]} ~~ Coral Golem Kill Task
				DoExpr {listadd[$AUTO_TRASH_ITEMS, `Gladiator Diemos Statue`]} ~~ Diemos
				DoExpr {listadd[$AUTO_TRASH_ITEMS, `Letter from Uber P`]} ~~ Mouf P
				DoExpr {listadd[$AUTO_TRASH_ITEMS, `Virindi Cage`]} ~~ Purge of Corruption
				DoExpr {listadd[$AUTO_TRASH_ITEMS, `Entryway Key`]} ~~ Lum
				DoExpr {listadd[$AUTO_TRASH_ITEMS, `Cellar Key`]} ~~ Lum
				DoExpr {listadd[$AUTO_TRASH_ITEMS, `Lord Cynreft Mhoire's Key`]} ~~ Graveyard Colo

	~~ Open Remote view
	IF: Always
		DO:	CreateView {Main} {:CheCommand-Main.xml}

	IF:	Expr {$LEVEL_DEBUG>=@CCDebug}
		DO:	DoExpr {echo[`[DEBUG] Che Command v`+$CCVersion+` by Che de Pa of Sundering`, $COLOR_DEBUG]}

	IF: Always
		DO: SetState {Init}
~~ }


STATE: {Init} ~~ {

	~~ If $MetaCallQueue is not a list create it
	IF: Expr {testvar[MetaCallQueue]==0}
		DO: DoExpr {setvar[MetaCallQueue, listcreate[]]}

	~~ Show Debug info about $MetaCallQueue
	IF: All
			Expr {listcount[$MetaCallQueue]>0}
			Expr {$LEVEL_DEBUG>=@CCDebug}
		DO: DoAll
				DoExpr {echo[`[DEBUG] $MetaCallQueue => `+$MetaCallQueue, $COLOR_DEBUG]}

	~~ Clear $MetaCallQueue if reset was used
	IF: Expr {$CCReset==true}
		DO: DoAll
				DoExpr {ifthen[$LEVEL_WARN>=@CCDebug, `echo[\`[WARN] Reset was called! Clearing queue\`, $COLOR_WARN]`, `false`]}
				DoExpr {listclear[$MetaCallQueue]}
				DoExpr {$CCReset=false}

	~~ Handle calling metas if there's some left in the queue
	IF: Expr {listcount[$MetaCallQueue]>0}
		DO: SetState {CallMeta}

	IF: Always
		DO: DoAll
				DoExpr {setvar[FoundTimers, listcreate[]]}

				DoExpr {setvar[CorpseBlacklist, listcreate[]]}
				DoExpr {setvar[StuckTimer, stopwatchstart[stopwatchcreate[]]]}
				DoExpr {$InitialPosition=getplayercoordinates[]}
				DoExpr {$InitialDistance=0}

				DoExpr {setvar[BlueSeen, listcreate[]]}

	~~ Enter Setup if `@CCCharacterList` or `@CCFellowname` is not set
	IF: Any
			Expr {listcount[@CCCharacterList]==0}
			Expr {@CCFellowname==`Not Set`}
		DO: SetState {Setup}

	~~ On initial startup display the characters that you will listen to
	IF: Expr {testvar[CCStarted]==false}
		DO: DoAll
				DoExpr {$CCStarted=true}
				DoExpr {echo[`[DEBUG] I am setup and will listen to commands`, $COLOR_DEBUG]}
				DoExpr {echo[`[DEBUG] I will listen to the following characters: `+@CCCharacterList, $COLOR_DEBUG]}
				DoExpr {echo[`[DEBUG] I will create fellows with the name: `+@CCFellowname, $COLOR_DEBUG]}

	~~ Wait for Leader if supposed to be following
	IF: All
			Expr {listcount[$MetaCallQueue]==0}
			Expr {@CCStay==false}
			Expr {@CCLeader!=$CHARACTER_NAME}
		DO: SetState {LeaderCheck}

	IF: Always
		DO: SetState {SetupViews}

~~ }


STATE: {Setup} ~~ {

	~~ Close all panels
	IF: Always
		DO: DoAll
				DestroyView {Actions}
				DestroyView {Empyrean}
				DestroyView {GiveSelect}
				DestroyView {Jump}
				DestroyView {Main}
				DestroyView {Profiles}
				DestroyView {Recalls}
				DestroyView {Settings}
				DestroyView {Subway}
				DestroyView {Timer}
				DestroyView {TownNetwork}

	~~ Show Setup panel
	IF: Not Expr {uiviewvisible[Setup]}
		DO: DoAll
				DoExpr {$CharacterOffset=0}
				CreateView {Setup} {:CheCommand-Setup.xml}
				SetState {SetSetup}

	~~ Display help information
	IF: Always
		DO: DoAll
				DoExpr {echo[`SETUP:`, $COLOR_DEBUG]}
				DoExpr {echo[`1) Create a fellowship with the name you'd like to use and the members who should listen to your commands.`, $COLOR_DEBUG]}
				DoExpr {echo[`2) Issue the command #addfellow to set the characters who should listen to commands and the fellow name it will create.`, $COLOR_DEBUG]}
				DoExpr {echo[`3) Issue the command #addchar Character Name for any additional characters who should listen to your commands.`, $COLOR_DEBUG]}
				DoExpr {echo[`4) Issue the command #finish when done to restart in normal mode.`, $COLOR_DEBUG]}
				DoExpr {echo[``, $COLOR_DEBUG]}
				DoExpr {echo[`I will listen to the following characters: `+@CCCharacterList, $COLOR_DEBUG]}
				DoExpr {echo[`I will create fellows with the name: `+@CCFellowname, $COLOR_DEBUG]}

	~~ Handle `#finish` for any character in ub netclients
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#finish\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[listmap[netclients[], `dictgetitem[$1, PlayerId]`], wobjectgetid[wobjectfindnearestbynameandobjectclass[$PLAYER, $capturegroup_name]]]}
		DO: DoAll
				DoExpr {ifthen[testpvar[CCLeader], `false`, `@CCLeader=listgetitem[@CCCharacterList, 0]`]}
				Chat {/vt meta load CheCommand}

	~~ Handle `#addfellow` for any character in ub netclients and a fellow is not formed
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#addfellow\"$} {}
			Expr {getfellowshipstatus[]==false}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[listmap[netclients[], `dictgetitem[$1, PlayerId]`], wobjectgetid[wobjectfindnearestbynameandobjectclass[$PLAYER, $capturegroup_name]]]}
		DO: DoAll
				DoExpr {echo[`[WARN] Not in a fellow and unable to add fellow characters!`, $COLOR_WARN]}
				SetState {Setup}

	~~ Handle `#addfellow` for any character in ub netclients and a fellow is formed
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#addfellow\"$} {}
			Expr {getfellowshipstatus[]==true}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[listmap[netclients[], `dictgetitem[$1, PlayerId]`], wobjectgetid[wobjectfindnearestbynameandobjectclass[$PLAYER, $capturegroup_name]]]}
		DO: DoAll
				DoExpr {@CCCharacterList=getfellownames[]}
				DoExpr {@CCFellowname=getfellowshipname[]}
				SetState {SetSetup}

	~~ Handle `#addchar` for any character in ub netclients
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#addchar (?<name>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[listmap[netclients[], `dictgetitem[$1, PlayerId]`], wobjectgetid[wobjectfindnearestbynameandobjectclass[$PLAYER, $capturegroup_name]]]}
		DO: DoAll
				DoExpr {listadd[@CCCharacterList, $capturegroup_name]}
				DoExpr {clearvar[$capturegroup_name]}
				SetState {SetSetup}

	~~ Handle `#removepos` for any character in ub netclients
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#removepos (?<position>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[listmap[netclients[], `dictgetitem[$1, PlayerId]`], wobjectgetid[wobjectfindnearestbynameandobjectclass[$PLAYER, $capturegroup_name]]]}
		DO: DoAll
				DoExpr {echo[`[INFO] Removing `+listgetitem[@CCCharacterList, cnumber[$capturegroup_position]]+` from Character List.`, $COLOR_INFO]}
				DoExpr {listremoveat[@CCCharacterList, cnumber[$capturegroup_position]]}
				DoExpr {clearvar[$capturegroup_position]}
				SetState {SetSetup}

~~ }


STATE: {SetSetup} ~~ {

	~~ Show all buttons
	IF: Always
		DO: DoAll
				DoExpr {uisetvisible[uigetcontrol[Setup, btnCharacter1], 1]}
				DoExpr {uisetvisible[uigetcontrol[Setup, btnCharacter2], 1]}
				DoExpr {uisetvisible[uigetcontrol[Setup, btnCharacter3], 1]}
				DoExpr {uisetvisible[uigetcontrol[Setup, btnCharacter4], 1]}
				DoExpr {uisetvisible[uigetcontrol[Setup, btnCharacter5], 1]}
				DoExpr {uisetvisible[uigetcontrol[Setup, btnCharacter6], 1]}
				DoExpr {uisetvisible[uigetcontrol[Setup, btnCharacter7], 1]}
				DoExpr {uisetvisible[uigetcontrol[Setup, btnCharacter8], 1]}
				DoExpr {uisetvisible[uigetcontrol[Setup, btnCharacter9], 1]}

				DoExpr {uisetvisible[uigetcontrol[Setup, btnCharacter1-delete], 1]}
				DoExpr {uisetvisible[uigetcontrol[Setup, btnCharacter2-delete], 1]}
				DoExpr {uisetvisible[uigetcontrol[Setup, btnCharacter3-delete], 1]}
				DoExpr {uisetvisible[uigetcontrol[Setup, btnCharacter4-delete], 1]}
				DoExpr {uisetvisible[uigetcontrol[Setup, btnCharacter5-delete], 1]}
				DoExpr {uisetvisible[uigetcontrol[Setup, btnCharacter6-delete], 1]}
				DoExpr {uisetvisible[uigetcontrol[Setup, btnCharacter7-delete], 1]}
				DoExpr {uisetvisible[uigetcontrol[Setup, btnCharacter8-delete], 1]}
				DoExpr {uisetvisible[uigetcontrol[Setup, btnCharacter9-delete], 1]}

				DoExpr {uisetvisible[uigetcontrol[Setup, btnNext], 1]}
				DoExpr {uisetvisible[uigetcontrol[Setup, btnPrevious], 1]}

	~~ Set all the buttons with the names of the profiles
	IF: Always
		DO: DoAll
				DoExpr {uisetlabel[uigetcontrol[Setup, btnCharacter1], ifthen[listcount[@CCCharacterList]>=1+$CharacterOffset, `@CCCharacterList{{0+$CharacterOffset}}`, `empty`]]}
				DoExpr {uisetlabel[uigetcontrol[Setup, btnCharacter2], ifthen[listcount[@CCCharacterList]>=2+$CharacterOffset, `@CCCharacterList{{1+$CharacterOffset}}`, `empty`]]}
				DoExpr {uisetlabel[uigetcontrol[Setup, btnCharacter3], ifthen[listcount[@CCCharacterList]>=3+$CharacterOffset, `@CCCharacterList{{2+$CharacterOffset}}`, `empty`]]}
				DoExpr {uisetlabel[uigetcontrol[Setup, btnCharacter4], ifthen[listcount[@CCCharacterList]>=4+$CharacterOffset, `@CCCharacterList{{3+$CharacterOffset}}`, `empty`]]}
				DoExpr {uisetlabel[uigetcontrol[Setup, btnCharacter5], ifthen[listcount[@CCCharacterList]>=5+$CharacterOffset, `@CCCharacterList{{4+$CharacterOffset}}`, `empty`]]}
				DoExpr {uisetlabel[uigetcontrol[Setup, btnCharacter6], ifthen[listcount[@CCCharacterList]>=6+$CharacterOffset, `@CCCharacterList{{5+$CharacterOffset}}`, `empty`]]}
				DoExpr {uisetlabel[uigetcontrol[Setup, btnCharacter7], ifthen[listcount[@CCCharacterList]>=7+$CharacterOffset, `@CCCharacterList{{6+$CharacterOffset}}`, `empty`]]}
				DoExpr {uisetlabel[uigetcontrol[Setup, btnCharacter8], ifthen[listcount[@CCCharacterList]>=8+$CharacterOffset, `@CCCharacterList{{7+$CharacterOffset}}`, `empty`]]}
				DoExpr {uisetlabel[uigetcontrol[Setup, btnCharacter9], ifthen[listcount[@CCCharacterList]>=9+$CharacterOffset, `@CCCharacterList{{8+$CharacterOffset}}`, `empty`]]}

	~~ Hide the empty buttons
	IF: Always
		DO: DoAll
				DoExpr {ifthen[listcount[@CCCharacterList]>=1+$CharacterOffset, `false`, `uisetvisible[uigetcontrol[Setup, btnCharacter1], 0]`]}
				DoExpr {ifthen[listcount[@CCCharacterList]>=2+$CharacterOffset, `false`, `uisetvisible[uigetcontrol[Setup, btnCharacter2], 0]`]}
				DoExpr {ifthen[listcount[@CCCharacterList]>=3+$CharacterOffset, `false`, `uisetvisible[uigetcontrol[Setup, btnCharacter3], 0]`]}
				DoExpr {ifthen[listcount[@CCCharacterList]>=4+$CharacterOffset, `false`, `uisetvisible[uigetcontrol[Setup, btnCharacter4], 0]`]}
				DoExpr {ifthen[listcount[@CCCharacterList]>=5+$CharacterOffset, `false`, `uisetvisible[uigetcontrol[Setup, btnCharacter5], 0]`]}
				DoExpr {ifthen[listcount[@CCCharacterList]>=6+$CharacterOffset, `false`, `uisetvisible[uigetcontrol[Setup, btnCharacter6], 0]`]}
				DoExpr {ifthen[listcount[@CCCharacterList]>=7+$CharacterOffset, `false`, `uisetvisible[uigetcontrol[Setup, btnCharacter7], 0]`]}
				DoExpr {ifthen[listcount[@CCCharacterList]>=8+$CharacterOffset, `false`, `uisetvisible[uigetcontrol[Setup, btnCharacter8], 0]`]}
				DoExpr {ifthen[listcount[@CCCharacterList]>=9+$CharacterOffset, `false`, `uisetvisible[uigetcontrol[Setup, btnCharacter9], 0]`]}

				DoExpr {ifthen[listcount[@CCCharacterList]>=1+$CharacterOffset, `false`, `uisetvisible[uigetcontrol[Setup, btnCharacter1-delete], 0]`]}
				DoExpr {ifthen[listcount[@CCCharacterList]>=2+$CharacterOffset, `false`, `uisetvisible[uigetcontrol[Setup, btnCharacter2-delete], 0]`]}
				DoExpr {ifthen[listcount[@CCCharacterList]>=3+$CharacterOffset, `false`, `uisetvisible[uigetcontrol[Setup, btnCharacter3-delete], 0]`]}
				DoExpr {ifthen[listcount[@CCCharacterList]>=4+$CharacterOffset, `false`, `uisetvisible[uigetcontrol[Setup, btnCharacter4-delete], 0]`]}
				DoExpr {ifthen[listcount[@CCCharacterList]>=5+$CharacterOffset, `false`, `uisetvisible[uigetcontrol[Setup, btnCharacter5-delete], 0]`]}
				DoExpr {ifthen[listcount[@CCCharacterList]>=6+$CharacterOffset, `false`, `uisetvisible[uigetcontrol[Setup, btnCharacter6-delete], 0]`]}
				DoExpr {ifthen[listcount[@CCCharacterList]>=7+$CharacterOffset, `false`, `uisetvisible[uigetcontrol[Setup, btnCharacter7-delete], 0]`]}
				DoExpr {ifthen[listcount[@CCCharacterList]>=8+$CharacterOffset, `false`, `uisetvisible[uigetcontrol[Setup, btnCharacter8-delete], 0]`]}
				DoExpr {ifthen[listcount[@CCCharacterList]>=9+$CharacterOffset, `false`, `uisetvisible[uigetcontrol[Setup, btnCharacter9-delete], 0]`]}

	~~ Hide the Previous button if you can't go back
	IF: Expr {$CharacterOffset<=0}
		DO: DoExpr {uisetvisible[uigetcontrol[Setup, btnPrevious], 0]}

	~~ Hide the Next button if you can't go foward
	IF: Expr {listcount[@CCCharacterList]<=9+$CharacterOffset}
		DO: DoExpr {uisetvisible[uigetcontrol[Setup, btnNext], 0]}

	~~ Return to Setup
	IF: Always
		DO: SetState {Setup}


~~ }


STATE: {SetupNextPage} ~~ {

	~~ Increment to the next page
	IF: Always
		DO: DoAll
				DoExpr {$CharacterOffset=$CharacterOffset+9}
				SetState {SetSetup}

~~ }


STATE: {SetupPreviousPage} ~~ {

	~~ Don't go into a negative offset
	IF: Expr {$CharacterOffset<=0}
		DO: SetState {SetSetup}

	~~ Decrement to the previous page
	IF: Always
		DO: DoAll
				DoExpr {$CharacterOffset=$CharacterOffset-9}
				SetState {SetSetup}
~~ }


STATE: {Idle} ~~ {

	~~ Announce if stuck
	IF: All
			Expr {@CCStay==false} ~~ Characters are following
			Expr {@CCLeader!=$CHARACTER_NAME} ~~ Not the leader
			Expr {getobjectinternaltype[$leaderObj]==$TYPE_OBJECT} ~~ Leader exists
			Expr {stopwatchelapsedseconds[$StuckTimer]>=@CCStuckAnnounceDelay} ~~ Announce when the $StuckTimer is above the delay
			Expr {coordinatedistancewithz[$InitialPosition, getplayercoordinates[]]<=@CCStuckThreshold} ~~ Character has not moved past the threshold
			Expr {getmotion[Forward]!=0} ~~ Character is moving
			Expr {isportaling[]==false} ~~ Character is not portaling
			Expr {$finalDistance=coordinatedistancewithz[wobjectgetphysicscoordinates[$leaderObj], getplayercoordinates[]]} ~~ Set $finalDistance
			Expr {$finalDistance>=@CCStuckDistanceThreshold} ~~ The distance to the leader is greater than the threshold
			Not Expr {$finalDistance>1000} ~~ The leader hasn't portaled away
		DO: DoAll
				ChatExpr {`/t `+@CCLeader+`, I am stuck and you are `+floor[$finalDistance]+` meters away!`}
				~~ ChatExpr {`/f InitialDistance: `+floor[$finalDistance]}
				~~ ChatExpr {`/f finalDistance: `+floor[$finalDistance]}
				SetState {Idle}

	~~ Restart stuck stopwatch
	IF: All
			Expr {@CCLeader!=$CHARACTER_NAME}
			Expr {stopwatchelapsedseconds[$StuckTimer]>=5}
		DO: DoAll
				DoExpr {$leaderObj=wobjectfindnearestbynameandobjectclass[$PLAYER, @CCLeader]}
				DoExpr {setvar[StuckTimer, stopwatchstart[stopwatchcreate[]]]}
				~~ DoExpr {$InitialDistance=coordinatedistancewithz[wobjectgetphysicscoordinates[$leaderObj], getplayercoordinates[]]}
				DoExpr {$InitialPosition=getplayercoordinates[]}
				SetState {Idle}

	~~ Use VR portal
	IF:	All
			Expr {getobjectinternaltype[wobjectfindnearestbynameandobjectclass[$NPC, `Viridian Portal`]]==$OBJECT}
			Expr {coordinatedistancewithz[wobjectgetphysicscoordinates[wobjectfindnearestbynameandobjectclass[$NPC, `Viridian Portal`]],getplayercoordinates[]]<$CLOSE_BLUE}
		DO:	SetState {UseVRPortal}

	~~ Find nearest Blue
	IF: All
			Expr {@CCAnnounceVRBlue==true}
			Expr {wobjectfindnearestbynameandobjectclass[$NPC, `Fiery Remains`]}
			Not Expr {listcontains[$BlueSeen, wobjectgetid[wobjectfindnearestbynameandobjectclass[$NPC, `Fiery Remains`]]]}
		DO: DoAll
				~~ coordinateparse in VTank does not output the height so we turn off the PatchExpressionEngine to use VTank instead of UtilityBelt
				Chat {/ub opt set VTank.PatchExpressionEngine false}
				ChatExpr {`Found Blue at `+coordinatetostring[coordinateparse[coordinatetostring[wobjectgetphysicscoordinates[wobjectfindnearestbynameandobjectclass[37, `Fiery Remains`]]]]]}  ~~ Can't use getvar for some reason throws error. 37=NPC
				Chat {/ub opt set VTank.PatchExpressionEngine true}

				ChatExpr {`/goarrow to `+coordinatetostring[wobjectgetphysicscoordinates[wobjectfindnearestbynameandobjectclass[$NPC, `Fiery Remains`]]]}

				DoExpr {listadd[$BlueSeen, wobjectgetid[wobjectfindnearestbynameandobjectclass[$NPC, `Fiery Remains`]]]}
				SetState {Idle}

	~~ Start stopwatch when Rynthid Weapons greentext appears
	IF: All
			CellE 2D310025  ~~ Next to Rynthid Weapons Portal
			Expr {@CCUseRynthidWeaponsPortal==true}
			ChatMatch {^With the last of the Warding Crystals shattered}
		DO: DoAll
				DoExpr {setvar[RynthidPortalWait, stopwatchstart[stopwatchcreate[]]]}
				SetState {Idle}

	~~ Use Rynthid Weapons portal after the stopwatch expires
	IF: All
			CellE 2D310025  ~~ Next to Rynthid Weapons Portal
			Expr {@CCUseRynthidWeaponsPortal==true}
			Expr {testvar[RynthidPortalWait]!=0}
			Expr {stopwatchelapsedseconds[$RynthidPortalWait]>=10}
			Expr {wobjectfindnearestbytemplatetype[$RYNTHID_WEAPONS_PORTAL]!=0}
			Expr {coordinatedistancewithz[wobjectgetphysicscoordinates[wobjectfindnearestbytemplatetype[$RYNTHID_WEAPONS_PORTAL]], getplayercoordinates[]]<=@CCPortalThreshold}
		DO: DoAll
				DoExpr {clearvar[RynthidPortalWait]}
				SetState {UsePortal}

	~~ Clear Rynthid Weapons stopwatch if not within range
	IF: All
			Expr {@CCUseRynthidWeaponsPortal==true}
			Expr {testvar[RynthidPortalWait]!=0}
			Expr {stopwatchelapsedseconds[$RynthidPortalWait]>=15}
			Expr {wobjectfindnearestbytemplatetype[$RYNTHID_WEAPONS_PORTAL]==0}
		DO: DoAll
				DoExpr {clearvar[RynthidPortalWait]}
				SetState {UsePortal}

	~~ Handle Auto Timers
	IF: All
			Expr {@CCAutoTimers==true}
			Expr {$FoundTimers=listfilter[$AutoTimers, `cnumber[getdatetimelocal[hh]]==$1{{0}}&&cnumber[getdatetimelocal[mm]]==$1{{1}}&&cnumber[getdatetimelocal[ss]]==$1{{2}}&&getdatetimelocal[tt]==$1{{3}}`]}
			Expr {listcount[$FoundTimers]>0}
		DO: SetState {HandleAutoTimers}

	~~ Display message if route is available
	IF: All
			ExitPortal
			Expr {listcount[listfilter[dictkeys[$CCRoutes], `cstrf[getplayerlandcell[], \`X8\`]==$1`]]>0}
		DO: DoAll
				DoExpr {echo[`[INFO] Available route found!`, $COLOR_INFO]}
				SetState {Idle}

	~~ Display message if profile is available
	IF: All
			ExitPortal
			Expr {listindexof[@CCProfileLandcellKeys, cstrf[getplayerlandcell[], `X8`]]!=-1}
		DO: DoAll
				DoExpr {echo[`[INFO] Available profile found!`, $COLOR_INFO]}
				SetState {Idle}

	~~ Display message if auto looting is available
	IF: All
			Expr {testvar[PreventAnnounceLooting]==false}
			Expr {listcount[listfilter[wobjectfindalllandscapebyobjectclass[$CORPSE], `listcontains[dictkeys[$AUTO_LOOT_CORPSES], wobjectgetstringprop[$1, $STRING_PROP_NAME]]`]]>0}
		DO: DoAll
				DoExpr {echo[`[INFO] Auto looting is available!`, $COLOR_INFO]}
				DoExpr {setvar[PreventAnnounceLooting, stopwatchstart[stopwatchcreate[]]]}
				SetState {Idle}

	~~ Clear $PreventAnnounceLooting stopwatch after timeout to re-enable announcements for when looting is available
	IF: All
			Expr {testvar[PreventAnnounceLooting]==true}
			Expr {stopwatchelapsedseconds[$PreventAnnounceLooting]>=@CCAnnounceLootingTimeout}
		DO: DoAll
				DoExpr {clearvar[PreventAnnounceLooting]}
				SetState {Idle}

	~~ Display message if auto giving is available
	IF: All
			Expr {testvar[PreventAnnounceGiving]==false}
			Expr {getobjectinternaltype[wobjectfindnearestbyobjectclass[$NPC]]==$TYPE_OBJECT}
			Expr {coordinatedistancewithz[wobjectgetphysicscoordinates[wobjectfindnearestbyobjectclass[$NPC]], getplayercoordinates[]]<=@CCAnnounceThreshold}
			Expr {dicthaskey[$AUTOGIVE_PROFILE, wobjectgetname[wobjectfindnearestbyobjectclass[$NPC]]]}
		DO: DoAll
				DoExpr {echo[`[INFO] Auto giving is available!`, $COLOR_INFO]}
				DoExpr {setvar[PreventAnnounceGiving, stopwatchstart[stopwatchcreate[]]]}
				SetState {Idle}

	~~ Clear $PreventAnnounceGiving stopwatch after timeout to re-enable announcements for when giving is available
	IF: All
			Expr {testvar[PreventAnnounceGiving]==true}
			Expr {stopwatchelapsedseconds[$PreventAnnounceGiving]>=@CCAnnounceGivingTimeout}
		DO: DoAll
				DoExpr {clearvar[PreventAnnounceGiving]}
				SetState {Idle}

	~~ Display message if buffs are low
	IF: All
			Expr {testvar[PreventAnnounceBuffs]==false}
			Expr {getspellexpirationbyname[@CCCheckBuffsSpell]<=@CCWarnBuffsDuration}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, My buffs are low!\`]`, `false`]}
				DoExpr {setvar[PreventAnnounceBuffs, stopwatchstart[stopwatchcreate[]]]}
				SetState {Idle}

	~~ Clear $PreventAnnounceBuff stopwatch after timeout to re-enable announcements for when buffs are running low
	IF: All
			Expr {testvar[PreventAnnounceBuffs]==true}
			Expr {stopwatchelapsedseconds[$PreventAnnounceBuffs]>=@CCAnnounceBuffsTimeout}
		DO: DoAll
				DoExpr {clearvar[PreventAnnounceBuffs]}
				SetState {Idle}

	~~ Display message if near luminance cap
	IF: All
			ChatMatch {^You've earned ([\d,]+) Luminance.$}
			Expr {getcharquadprop[6]>=@CCWarnLuminance}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, I am near my luminance cap!\`]`, `false`]}
				SetState {Idle}

	~~ Display message if receiving a Chorizite Threaded Pack Token
	IF: ChatMatch {(?:Lord Kresovus|Neelic|Raksaa|Sergeant Trebuus) gives you Chorizite Threaded Pack Token}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, I received a Chorizite Threaded Pack Token!\`]`, `false`]}
				SetState {Idle}

	~~ Start a timer for Rynthid Weapons wave one
	IF: All
			Expr {@CCTimerWeapons==true}
			ChatMatch {^A voice echos in your mind, "So, you've worked so hard to find me. You've interrupted my experiments and you've interfered with my plans.}
		DO: DoAll
				DoExpr {$CCTimerAmount=310}
				DoExpr {$CCTimerMsg=@CCTimerWeaponsMsg}
				DoExpr {setvar[CCTimer, stopwatchstart[stopwatchcreate[]]]}
				CreateView {Timer} {:CheCommand-Timer.xml}
				SetState {Idle}

	~~ Start a timer for VR Speed runs
	IF: All
			Expr {@CCTimerVR==true}
			ChatMatch {The leader of your fellowship has paid the 100 Infused Amber Shards, let us begin}
		DO: DoAll
				DoExpr {$CCTimerAmount=60*30}
				DoExpr {$CCTimerMsg=@CCTimerVRMsg}
				DoExpr {setvar[CCTimer, stopwatchstart[stopwatchcreate[]]]}
				CreateView {Timer} {:CheCommand-Timer.xml}
				SetState {Idle}

	~~ Handle timer message
	IF: All
			Expr {testvar[CCTimer]!=false}
			Expr {testvar[CCTimerMsg]!=false}
			Expr {getobjectinternaltype[$CCTimerMsg]==$TYPE_STRING}
			Expr {$CCTimerAmount-stopwatchelapsedseconds[$CCTimer]<=0}
		DO: DoAll
				ChatExpr {$CCTimerMsg}
				SetState {Idle}

	~~ Handle timer going off
	IF: All
			Expr {testvar[CCTimer]!=false}
			Expr {$CCTimerAmount-stopwatchelapsedseconds[$CCTimer]<=0}
		DO: DoAll
				DoExpr {clearvar[CCTimer]}
				DoExpr {clearvar[CCTimerAmount]}
				DoExpr {clearvar[CCTimerMsg]}
				DoExpr {echo[`[INFO] ==============`, $COLOR_INFO]}
				DoExpr {echo[`[INFO] Timer is done!`, $COLOR_INFO]}
				DoExpr {echo[`[INFO] ==============`, $COLOR_INFO]}
				DestroyView {Timer}
				SetState {Idle}

	~~ Handle `#setup` for any character in ub netclients
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#setup\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[listmap[netclients[], `dictgetitem[$1, PlayerId]`], wobjectgetid[wobjectfindnearestbynameandobjectclass[$PLAYER, $capturegroup_name]]]}
		DO: DoAll
				SetState {Setup}

	~~ Handle Actions
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#action (?<actiontext>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleActions}

	~~ Handle `#fellow add`
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#fellow add (?<namerx>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {FellowAdd}

	~~ Handle Fellows
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#fellow (?<fellowtext>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleFellow}

	~~ Handle Navigation
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#navto (?<navdestination>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleNavigation}

	~~ Handle Quests
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#quest (?<questdestination>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleQuests}

	~~ Handle Routes
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#route\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleRoute}

	~~ Load Profiles
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#profile\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {AutoloadProfile}

	~~ Handle `#profile add`
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#profile add (?<profilename>.*) (?<profilevalue>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {ProfileAdd}

	~~ Handle `#profile addlandcell`
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#profile addlandcell (?<profilename>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {ProfileAddLandcell}

	~~ Handle `#profile load`
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#profile load (?<profilename>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {ProfileLoad}

	~~ Handle Profiles
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#profile (?<profiletext>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleProfile}

	~~ Handle `#meta load`
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#meta load (?<nickname>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {MetaLoad}

	~~ Handle `#meta remove`
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#meta remove (?<nickname>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {MetaRemove}

	~~ Handle `#meta add`
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#meta add (?<nickname>.*) (?<metafilename>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {MetaAdd}

	~~ Handle Metas
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#meta (?<metatext>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleMetas}

	~~ Handle Killtasks
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#killtask (?<flagaction>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleKilltask}

	~~ Handle Auto Looting
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#loot\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {AutoLoot}

	~~ Handle Looting
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#loot (?<item>.*) from (?<corpse>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleLooting}

	~~ Handle Looting Info
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#loot (?<loottext>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleLootingInfo}

	~~ Handle Facing a direction
	IF: All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#face (?<facedirection>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleFace}

	~~ Handle Jumping text
	IF: All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#jump (?<jumptext>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleJumping}

	~~ Handle Picking up items
	IF: All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#pickup (?<itemtext>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandlePickup}

	~~ Handle Auto Giving items
	IF: All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#give\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {AutoGive}

	~~ Handle Giving items
	IF: All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#give (?<itemtext>.+?)(?: to (?<giveto>.*))?\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleGive}

	~~ Handle Trashing items
	IF: All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#trash(?: (?<trashtext>.*))?\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleTrash}

	~~ Handle Passing items
	IF: All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#pass (?<passtext>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandlePass}

	~~ Handle Use
	IF: All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#use (?<usetext>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleUse}

	~~ Handle Checking
	IF: All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#check (?<checktext>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleCheck}

	~~ Handle Counting
	IF: All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#count (?<counttext>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleCount}

	~~ Handle Timers
	IF: All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#timer (?<timertext>(?:help|\d+(?:\.\d+)?))(?:\s+(?<timermsg>.+))?\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {HandleTimers}

	~~ Handle VTank Options
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#vtoption (?<optiontext>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: DoAll
				ChatExpr {`/vt opt set `+$capturegroup_optiontext}
				SetState {Idle}

	~~ Handle Echo
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#echo (?<echotext>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: DoAll
				ChatExpr {$capturegroup_echotext}
				SetState {Idle}

	~~ Handle Version
	IF: ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#version\"$} {}
		DO: DoAll
				DoExpr {chatbox[`/t `+$capturegroup_name+`, CheCommand `+$CCVersion]}
				SetState {Idle}

	~~ Cast the Focusing Stones's Brillence on a player for the issuer of the command
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#brill(?: (?<brillname>.*))?\"$} {}
			Expr {$capturegroup_name==false}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {Brill}

	~~ Cast the Royal Bouquet's Blessing on a player for the issuer of the command
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#blessing(?: (?<blessingname>.*))?\"$} {}
			Expr {$capturegroup_name==false}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {Blessing}

	~~ Update Timer countdown original
	~~ IF: All
	~~ 		Expr {testvar[CCTimer]!=false}
	~~ 		Expr {uiviewvisible[Timer]}
	~~ 	DO: DoAll
	~~ 			DoExpr {$total_seconds=$CCTimerAmount-stopwatchelapsedseconds[$CCTimer]}
	~~ 			DoExpr {$hours=floor[$total_seconds/3600]}
	~~ 			DoExpr {$remaining_seconds=$total_seconds%3600}
	~~ 			DoExpr {$minutes=floor[$remaining_seconds/60]}
	~~ 			DoExpr {$seconds=$remaining_seconds%60}
	~~ 			DoExpr {uisetlabel[uigetcontrol[Timer, Timer], cstrf[$minutes, `00`]+`:`+cstrf[$seconds, `00`]]}
	~~ 			SetState {Idle}

	~~ Update Timer countdown left hand side
	IF: All
			Expr {testvar[CCTimer]!=false}
			Expr {uiviewvisible[Timer]}
			Expr {$total_seconds=$CCTimerAmount-stopwatchelapsedseconds[$CCTimer]}
			Expr {uisetlabel[uigetcontrol[Timer, Timer], cstrf[floor[$total_seconds%3600/60], `00`]+`:`+cstrf[$total_seconds%3600%60, `00`]]}
			Never
		DO: None


~~ }


STATE: {HandleAutoTimers} ~~ {

	~~ Return to Idle if no timers found
	IF: Expr {listcount[$FoundTimers]==0}
		DO: SetState {Idle}

	~~ Pop $FoundTimers and CallMeta
	IF: Always
		DO: DoAll
				DoExpr {$timer=listpop[$FoundTimers, 0]}
				DoExpr {$MetaCallQueue=$timer{{4}}}
				SetState {CallMeta}

~~ }

STATE: {CallMeta} ~~ {

	~~ Call a meta with the return meta being CheCommand
	IF: Expr {listcount[$MetaCallQueue]>0}
		DO: DoAll
				DoExpr {$meta=listpop[$MetaCallQueue, 0]}
				DoExpr {$CCReturnMeta=`CheCommand`}
				ChatExpr {`/vt meta load `+$meta}

~~ }


STATE: {HandleActions} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	IF: Expr {(help)#getvar[capturegroup_actiontext]}
		DO: DoAll
				DoExpr {echo[`#action contracts: All characters read contracts in inventory`, $COLOR_INFO]}
				DoExpr {echo[`#action follow: All characters follow the initiator of the follow command`, $COLOR_INFO]}
				DoExpr {echo[`#action update: All characters reload the meta with the latest changes`, $COLOR_INFO]}
				DoExpr {echo[`#action mule: All characters navigate to Sort de Che and mule`, $COLOR_INFO]}
				DoExpr {echo[`#action npc: All characters use the nearest NPC`, $COLOR_INFO]}
				DoExpr {echo[`#action pack: All characters use mag tools auto pack`, $COLOR_INFO]}
				DoExpr {echo[`#action peace: All characters enter peace mode`, $COLOR_INFO]}
				DoExpr {echo[`#action portal: All characters use the nearest portal`, $COLOR_INFO]}
				DoExpr {echo[`#action quit: All characters exit the game`, $COLOR_INFO]}
				DoExpr {echo[`#action stay: All characters stop following`, $COLOR_INFO]}
				DoExpr {echo[`#action vendor: All characters use the nearest Vendor`, $COLOR_INFO]}
				SetState {Idle}

	~~ Handle `#action stay`
	IF: Expr {(stay)#getvar[capturegroup_actiontext]}
		DO:	DoAll
				EmbedNav Empty {[None]}
				DoExpr {@CCStay=true}
				SetState {Idle}

	~~ Handle `#action follow` for followers
	IF:	All
			Expr {(follow)#getvar[capturegroup_actiontext]}
			Expr {$capturegroup_name!=false}
		DO:	DoAll
				SetOpt {NavPriorityBoost} {true}
				ChatExpr {`/ub follow `+$capturegroup_name}
				DoExpr {@CCLeader=$capturegroup_name}
				DoExpr {@CCStay=false}
				SetState {Idle}

	~~ Handle `#action follow` for person who issued command
	IF:	All
			Expr {(follow)#getvar[capturegroup_actiontext]}
			Expr {$capturegroup_name==false}
		DO:	DoAll
				EmbedNav Empty {[None]}
				DoExpr {@CCLeader=$CHARACTER_NAME}
				DoExpr {@CCStay=false}
				SetState {Idle}

	~~ Handle `#action contracts`
	IF: Expr {(contracts)#getvar[capturegroup_actiontext]}
		DO:	SetState {ReadContracts}

	~~ Handle `#action update`
	IF: Expr {(update)#getvar[capturegroup_actiontext]}
		DO: Chat {/vt meta load CheCommand}

	~~ Handle `#action pack`
	IF: Expr {(pack)#getvar[capturegroup_actiontext]}
		DO: DoAll
				Chat {/mt autopack}
				SetState {Idle}

	~~ Handle `#action mule`
	IF: Expr {(mule)#getvar[capturegroup_actiontext]}
		DO: DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavSort`]}
				DoExpr {listadd[$MetaCallQueue, `CheCommandHandoffSort`]}
				SetState {CallMeta}

	~~ Handle `#action portal`
	IF: Expr {(portal)#getvar[capturegroup_actiontext]}
		DO: SetState {UsePortal}

	~~ Handle `#action quit`
	IF: Expr {(quit)#getvar[capturegroup_actiontext]}
		DO: ChatExpr {`/ub quit`}

	~~ Handle `#action npc`
	IF: Expr {(npc)#getvar[capturegroup_actiontext]}
		DO: SetState {UseNPC}

	~~ Handle `#action buff`
	IF: Expr {(buff)#getvar[capturegroup_actiontext]}
		DO: DoAll
				SetOpt {EnableBuffing} {True}
				Chat {/vt forcebuff}
				SetState {Idle}

	~~ Handle `#action peace`
	IF: Expr {(peace)#getvar[capturegroup_actiontext]}
		DO: DoAll
				DoExpr {setcombatstate[peace]}
				SetState {Idle}

	~~ Handle `#action vendor`
	IF: Expr {(vendor)#getvar[capturegroup_actiontext]}
		DO: SetState {UseVendor}

	~~ Handle no match for actiontext
	IF: Expr {$LEVEL_WARN>=@CCDebug}
		DO: DoAll
				DoExpr {echo[`[WARN] No matching action for #action`, $COLOR_WARN]}
				SetState {Idle}

~~ }


STATE: {HandleNavigation} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	IF: Expr {(help)#getvar[capturegroup_navdestination]}
		DO: DoAll
				DoExpr {echo[`#navto aerlinthe: Navigate to Aerlinthe (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto aphus lassel: Navigate to Aphus Lassel (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto asherons castle: Navigate to Asheron's Castle`, $COLOR_INFO]}
				DoExpr {echo[`#navto bur: Navigate to Bur (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto candeth: Navigate to Candeth Keep (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto colosseum: Navigate to Colosseum (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto comps: Navigate to Haven and purchase comps`, $COLOR_INFO]}
				DoExpr {echo[`#navto couch: Navigate to Haven and sit on the couch`, $COLOR_INFO]}
				DoExpr {echo[`#navto frozen valley: Navigate to Frozen Valley (requires flagging)`, $COLOR_INFO]}
				DoExpr {echo[`#navto facility hub: Navigate to Facility Hub (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto haven buffs: Navigate to Haven and use all buffing items`, $COLOR_INFO]}
				DoExpr {echo[`#navto hoshino: Navigate to Hoshino tent (requires flagging)`, $COLOR_INFO]}
				DoExpr {echo[`#navto gear knight: Navigate to Gear Knights (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto glenden wood: Navigate to Glenden Wood (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto graveyard: Navigate to Graveyard (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto mount lethe: Navigate to Mount Lethe (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto neftet: Navigate to Neftet (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto singularity caul: Navigate to Singularity Caul (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto rynthid: Navigate to Rynthid (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto viridian rise: Navigate to Viridian Rise (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto viridian rise tree: Navigate to Viridian Rise Tree (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto sanctuary: Navigate to Sanctuary (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto secondary: Navigate to Secondary Portal Recall (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto ulgrims: Navigate to Ulgrim's Recall (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto lifestone: Navigate to Lifestone (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto lifestone recall: Navigate to Lifestone Recall (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto primary: Navigate to Primary Portal Recall (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`#navto portal recall: Navigate to Portal Recall (requires spell)`, $COLOR_INFO]}
				DoExpr {echo[`Town Network (Annex):`, $COLOR_INFO]}
				DoExpr {echo[`#navto ahurenga: Navigate to Ahurenga`, $COLOR_INFO]}
				DoExpr {echo[`#navto bluespire: Navigate to Bluespire`, $COLOR_INFO]}
				DoExpr {echo[`#navto danbys outpost: Navigate to Danby's Outpost`, $COLOR_INFO]}
				DoExpr {echo[`#navto eastwatch: Navigate to Eastwatch`, $COLOR_INFO]}
				DoExpr {echo[`#navto fiun outpost: Navigate to Fiun Outpost`, $COLOR_INFO]}
				DoExpr {echo[`#navto greenspire: Navigate to Greenspire`, $COLOR_INFO]}
				DoExpr {echo[`#navto linvak tukal: Navigate to Linvak Tukal`, $COLOR_INFO]}
				DoExpr {echo[`#navto neydisa castle: Navigate to Neydisa Castle`, $COLOR_INFO]}
				DoExpr {echo[`#navto oolutungas refuge: Navigate to Oolutanga's Refuge`, $COLOR_INFO]}
				DoExpr {echo[`#navto redspire: Navigate to Redspire`, $COLOR_INFO]}
				DoExpr {echo[`#navto sanamar: Navigate to Sanamar`, $COLOR_INFO]}
				DoExpr {echo[`#navto silyun: Navigate to Silyun`, $COLOR_INFO]}
				DoExpr {echo[`#navto timaru: Navigate to Timaru`, $COLOR_INFO]}
				DoExpr {echo[`#navto westwatch: Navigate to Westwatch`, $COLOR_INFO]}
				DoExpr {echo[`Town Network (Sho):`, $COLOR_INFO]}
				DoExpr {echo[`#navto baishi: Navigate to Baishi`, $COLOR_INFO]}
				DoExpr {echo[`#navto freehold: Navigate to Freehold`, $COLOR_INFO]}
				DoExpr {echo[`#navto hebian-to: Navigate to Hebian-To`, $COLOR_INFO]}
				DoExpr {echo[`#navto kara: Navigate to Kara`, $COLOR_INFO]}
				DoExpr {echo[`#navto kryst: Navigate to Kryst`, $COLOR_INFO]}
				DoExpr {echo[`#navto lin: Navigate to Lin`, $COLOR_INFO]}
				DoExpr {echo[`#navto mayoi: Navigate to Mayoi`, $COLOR_INFO]}
				DoExpr {echo[`#navto nanto: Navigate to Nanto`, $COLOR_INFO]}
				DoExpr {echo[`#navto sawato: Navigate to Sawato`, $COLOR_INFO]}
				DoExpr {echo[`#navto shoushi: Navigate to Shoushi`, $COLOR_INFO]}
				DoExpr {echo[`#navto tou-tou: Navigate to Tou-Tou`, $COLOR_INFO]}
				DoExpr {echo[`#navto yanshi: Navigate to Yanshi`, $COLOR_INFO]}
				DoExpr {echo[`Town Network (Gharu'ndim):`, $COLOR_INFO]}
				DoExpr {echo[`#navto al-arqas: Navigate to Al-Arqas`, $COLOR_INFO]}
				DoExpr {echo[`#navto al-jalima: Navigate to Al-Jalima`, $COLOR_INFO]}
				DoExpr {echo[`#navto khayyaban: Navigate to Khayyaban`, $COLOR_INFO]}
				DoExpr {echo[`#navto qalabar: Navigate to Qalaba'r`, $COLOR_INFO]}
				DoExpr {echo[`#navto samsur: Navigate to Samsur`, $COLOR_INFO]}
				DoExpr {echo[`#navto tufa: Navigate to Tufa`, $COLOR_INFO]}
				DoExpr {echo[`#navto uziz: Navigate to Uziz`, $COLOR_INFO]}
				DoExpr {echo[`#navto xarabydun: Navigate to Xarabydun`, $COLOR_INFO]}
				DoExpr {echo[`#navto yaraq: Navigate to Yaraq`, $COLOR_INFO]}
				DoExpr {echo[`#navto zaikhal: Navigate to Zaikhal`, $COLOR_INFO]}
				DoExpr {echo[`Town Network (Aluvian):`, $COLOR_INFO]}
				DoExpr {echo[`#navto arwic: Navigate to Arwic`, $COLOR_INFO]}
				DoExpr {echo[`#navto cragstone: Navigate to Cragstone`, $COLOR_INFO]}
				DoExpr {echo[`#navto dryreach: Navigate to Dryreach`, $COLOR_INFO]}
				DoExpr {echo[`#navto eastham: Navigate to Eastham`, $COLOR_INFO]}
				DoExpr {echo[`#navto fort tethana: Navigate to Fort Tethana`, $COLOR_INFO]}
				DoExpr {echo[`#navto glenden wood: Navigate to Glenden Wood`, $COLOR_INFO]}
				DoExpr {echo[`#navto holtburg: Navigate to Holtburg`, $COLOR_INFO]}
				DoExpr {echo[`#navto lytelthorpe: Navigate to Lytelthorpe`, $COLOR_INFO]}
				DoExpr {echo[`#navto plateau village: Navigate to Plateau Village`, $COLOR_INFO]}
				DoExpr {echo[`#navto rithwic: Navigate to Rithwic`, $COLOR_INFO]}
				DoExpr {echo[`#navto stonehold: Navigate to Stonehold`, $COLOR_INFO]}
				DoExpr {echo[`#navto candeth keep: Navigate to Candeth Keep`, $COLOR_INFO]}

				SetState {Idle}

	~~ Handle `#navto comps`
	IF: Expr {(comps)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavRecomp`]}
				SetState {CallMeta}

	~~ Handle `#navto haven buffs`
	IF: Expr {(haven buffs)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavHavenBuffs`]}
				SetState {CallMeta}

	~~ Handle `#navto colosseum`
	IF: Expr {(colosseum)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=4213} ~~ Colosseum Recall
				SetState {HandleRecall}

	~~ Handle `#navto facility hub`
	IF: Expr {(facility hub)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=5175} ~~ Facility Hub Recall
				SetState {HandleRecall}

	~~ Handle `#navto glenden wood`
	IF: Expr {(glenden wood)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=3865} ~~ Glenden Wood Recall
				SetState {HandleRecall}

	~~ Handle `#navto ulgrims`
	IF: Expr {(ulgrims)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=2941} ~~ Ulgrim's Recall
				SetState {HandleRecall}

	~~ Handle `#navto candeth`
	IF: Expr {(candeth)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=4214} ~~ Candeth's Keep Recall
				SetState {HandleRecall}

	~~ Handle `#navto bur`
	IF: Expr {(bur)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=4084} ~~ Bur Recall
				SetState {HandleRecall}

	~~ Handle `#navto mount lethe`
	IF: Expr {(mount lethe)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=2813} ~~ Mount Lethe Recall
				SetState {HandleRecall}

	~~ Handle `#navto couch`
	IF: Expr {(couch)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavChair`]}
				SetState {CallMeta}

	~~ Handle `#navto asheron castle`
	IF: Expr {(asherons castle)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavPortalspaceActivator`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavPortalspaceActivator`, dictcreate[`destination`, `AsheronsCastle`]]}
				SetState {CallMeta}

	~~ Handle `#navto frozen valley`
	IF: Expr {(frozen valley)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavPortalspaceActivator`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavPortalspaceActivator`, dictcreate[`destination`, `FrozenValley`]]}
				SetState {CallMeta}

	~~ Handle `#navto hoshino`
	IF: Expr {(hoshino)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavPortalspaceActivator`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavPortalspaceActivator`, dictcreate[`destination`, `Hoshino`]]}
				SetState {CallMeta}

	~~ Handle `#navto graveyard`
	IF: Expr {(graveyard)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=4128} ~~ Call of the Mhoire Forge
				SetState {HandleRecall}

	~~ Handle `#navto neftet`
	IF: Expr {(neftet)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavNeftet`]}
				SetState {CallMeta}

	~~ Handle `#navto singularity caul`
	IF: Expr {(singularity caul)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=2943} ~~ Recall to the Singularity Caul
				SetState {HandleRecall}

	~~ Handle `#navto rynthid`
	IF: Expr {(rynthid)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=6150} ~~ Rynthid Recall
				SetState {HandleRecall}

	~~ Handle `#navto olthoi`
	IF: Expr {(olthoi)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=4198} ~~ Olthoi North Recall
				SetState {HandleRecall}

	~~ Handle `#navto viridian rise`
	IF: Expr {(viridian rise)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=6321} ~~ Viridian Rise Recall
				SetState {HandleRecall}

	~~ Handle `#navto viridian rise tree`
	IF: Expr {(viridian rise tree)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=6322} ~~ Viridian Rise Tree Recall
				SetState {HandleRecall}

	~~ Handle `#navto gearknight`
	IF: Expr {(gear knight)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=5330} ~~ Gear Knight Invasion Area Camp Recall
				SetState {HandleRecall}

	~~ Handle `#navto aphus lassel`
	IF: Expr {(aphus lassel)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=2931} ~~ Recall Aphus Lassel
				SetState {HandleRecall}

	~~ Handle `#navto aerlinthe`
	IF: Expr {$capturegroup_navdestination==`aerlinthe`}  ~~ Prevent aerlinthe from eating Lin destination
		DO:	DoAll
				DoExpr {$CCRecallSpell=2041} ~~ Aerlinthe Recall
				SetState {HandleRecall}

	~~ Handle `#navto sanctuary`
	IF: Expr {(sanctuary)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=2023} ~~ Recall Sanctuary
				SetState {HandleRecall}

	~~ Handle `#navto gear knight`
	IF: Expr {(gear knight)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=5330} ~~ Gear Knight Invasion Area Camp Recall
				SetState {HandleRecall}

	~~ Handle `#navto lifestone`
	IF: Expr {(lifestone)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=1636} ~~ Lifestone Sending
				SetState {HandleRecall}

	~~ Handle `#navto lifestone recall`
	IF: Expr {(lifestone recall)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=1635} ~~ Lifestone recall
				SetState {HandleRecall}

	~~ Handle `#navto portal recall`
	IF: Expr {(portal recall)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=2645} ~~ Portal Recall
				SetState {HandleRecall}

	~~ Handle `#navto primary`
	IF: Expr {(primary)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=48} ~~ Primary Portal Recall
				SetState {HandleRecall}

	~~ Handle `#navto secondary`
	IF: Expr {(secondary)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=2647} ~~ Secondary Portal Recall
				SetState {HandleRecall}

	~~ Handle `#navto primary summon`
	IF: Expr {(primary summon)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=157} ~~ Primary Summon Portal
				SetState {HandleSummonPortal}

	~~ Handle `#navto secondary`
	IF: Expr {(secondary summon)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {$CCRecallSpell=2648} ~~ Secondary Summon Portal
				SetState {HandleSummonPortal}



	~~ Annex

	~~ Handle `#navto ahurenga`
	IF: Expr {(ahurenga)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Ahurenga`]]}
				SetState {CallMeta}

	~~ Handle `#navto bluespire`
	IF: Expr {(bluespire)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Bluespire`]]}
				SetState {CallMeta}

	~~ Handle `#navto danbys outpost`
	IF: Expr {(danbys outpost)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Danby's Outpost`]]}
				SetState {CallMeta}

	~~ Handle `#navto eastwatch`
	IF: Expr {(eastwatch)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Eastwatch`]]}
				SetState {CallMeta}

	~~ Handle `#navto fiun outpost`
	IF: Expr {(fiun outpost)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Fiun Outpost`]]}
				SetState {CallMeta}

	~~ Handle `#navto greenspire`
	IF: Expr {(greenspire)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Greenspire`]]}
				SetState {CallMeta}

	~~ Handle `#navto linvak tukal`
	IF: Expr {$capturegroup_navdestination==`linvak tukal`}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Linvak Tukal`]]}
				SetState {CallMeta}

	~~ Handle `#navto neydisa castle`
	IF: Expr {(neydisa castle)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Neydisa Castle`]]}
				SetState {CallMeta}

	~~ Handle `#navto oolutangas refuge`
	IF: Expr {(oolutangas refuge)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Oolutanga's Refuge`]]}
				SetState {CallMeta}

	~~ Handle `#navto redspire`
	IF: Expr {(redspire)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Redspire`]]}
				SetState {CallMeta}

	~~ Handle `#navto sanamar`
	IF: Expr {(sanamar)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Sanamar`]]}
				SetState {CallMeta}

	~~ Handle `#navto silyun`
	IF: Expr {(silyun)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Silyun`]]}
				SetState {CallMeta}

	~~ Handle `#navto timaru`
	IF: Expr {(timaru)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Timaru`]]}
				SetState {CallMeta}

	~~ Handle `#navto westwatch`
	IF: Expr {(westwatch)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Westwatch`]]}
				SetState {CallMeta}

	~~ Sho

	~~ Handle `#navto baishi`
	IF: Expr {(baishi)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Baishi`]]}
				SetState {CallMeta}

	~~ Handle `#navto freehold`
	IF: Expr {(freehold)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Freehold`]]}
				SetState {CallMeta}

	~~ Handle `#navto hebian-to`
	IF: Expr {(hebian-to)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Hebian-To`]]}
				SetState {CallMeta}

	~~ Handle `#navto kara`
	IF: Expr {(kara)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Kara`]]}
				SetState {CallMeta}

	~~ Handle `#navto kryst`
	IF: Expr {(kryst)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Kryst`]]}
				SetState {CallMeta}

	~~ Handle `#navto lin`
	IF: Expr {(lin)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Lin`]]}
				SetState {CallMeta}

	~~ Handle `#navto mayoi`
	IF: Expr {(mayoi)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Mayoi`]]}
				SetState {CallMeta}

	~~ Handle `#navto nanto`
	IF: Expr {(nanto)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Nanto`]]}
				SetState {CallMeta}

	~~ Handle `#navto sawato`
	IF: Expr {(sawato)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Sawato`]]}
				SetState {CallMeta}

	~~ Handle `#navto shoushi`
	IF: Expr {(shoushi)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Shoushi`]]}
				SetState {CallMeta}

	~~ Handle `#navto tou-tou`
	IF: Expr {(tou-tou)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Tou-Tou`]]}
				SetState {CallMeta}

	~~ Handle `#navto yanshi`
	IF: Expr {(yanshi)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Yanshi`]]}
				SetState {CallMeta}


	~~ Gharu


	~~ Handle `#navto al-arqas`
	IF: Expr {(al-arqas)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Al-Arqas`]]}
				SetState {CallMeta}

	~~ Handle `#navto al-jalima`
	IF: Expr {(al-jalima)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Al-Jalima`]]}
				SetState {CallMeta}

	~~ Handle `#navto khayyaban`
	IF: Expr {(khayyaban)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Khayyaban`]]}
				SetState {CallMeta}

	~~ Handle `#navto qalabar`
	IF: Expr {(qalabar)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Qalaba'r`]]}
				SetState {CallMeta}

	~~ Handle `#navto samsur`
	IF: Expr {(samsur)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Samsur`]]}
				SetState {CallMeta}

	~~ Handle `#navto tufa`
	IF: Expr {(tufa)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Tufa`]]}
				SetState {CallMeta}

	~~ Handle `#navto uziz`
	IF: Expr {(uziz)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Uziz`]]}
				SetState {CallMeta}

	~~ Handle `#navto xarabydun`
	IF: Expr {(xarabydun)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Xarabydun`]]}
				SetState {CallMeta}

	~~ Handle `#navto yaraq`
	IF: Expr {(yaraq)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Yaraq`]]}
				SetState {CallMeta}

	~~ Handle `#navto zaikhal`
	IF: Expr {(zaikhal)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Zaikhal`]]}
				SetState {CallMeta}


	~~ Aluvian


	~~ Handle `#navto arwic`
	IF: Expr {(arwic)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Arwic`]]}
				SetState {CallMeta}

	~~ Handle `#navto cragstone`
	IF: Expr {(cragstone)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Cragstone`]]}
				SetState {CallMeta}

	~~ Handle `#navto dryreach`
	IF: Expr {(dryreach)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Dryreach`]]}
				SetState {CallMeta}

	~~ Handle `#navto eastham`
	IF: Expr {(eastham)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Eastham`]]}
				SetState {CallMeta}

	~~ Handle `#navto fort tethana`
	IF: Expr {(fort tethana)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Fort Tethana`]]}
				SetState {CallMeta}

	~~ Handle `#navto glenden wood`
	IF: Expr {(glenden wood)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Glenden Wood`]]}
				SetState {CallMeta}

	~~ Handle `#navto holtburg`
	IF: Expr {(holtburg)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Holtburg`]]}
				SetState {CallMeta}

	~~ Handle `#navto lytelthorpe`
	IF: Expr {(lytelthorpe)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Lytelthorpe`]]}
				SetState {CallMeta}

	~~ Handle `#navto plateau village`
	IF: Expr {(plateau village)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Plateau Village`]]}
				SetState {CallMeta}

	~~ Handle `#navto rithwic`
	IF: Expr {(rithwic)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Rithwic`]]}
				SetState {CallMeta}

	~~ Handle `#navto stonehold`
	IF: Expr {(stonehold)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavTownNetwork`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavTownNetwork`, dictcreate[`destination`, `Stonehold`]]}
				SetState {CallMeta}

	~~ Subway

	~~ Handle `#navto candeth keep`
	IF: Expr {(candeth keep)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavSubway`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavSubway`, dictcreate[`destination`, `Candeth Keep`]]}
				SetState {CallMeta}

	~~ Handle `#navto jungle subs`
	IF: Expr {(jungle subs)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavSubway`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavSubway`, dictcreate[`destination`, `Jungle Subs`]]}
				SetState {CallMeta}

	~~ Handle `#navto withered`
	IF: Expr {(withered)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavSubway`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavSubway`, dictcreate[`destination`, `Withered`]]}
				SetState {CallMeta}

	~~ Handle `#navto mid direlands`
	IF: Expr {(mid direlands)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavSubway`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavSubway`, dictcreate[`destination`, `Mid Direlands`]]}
				SetState {CallMeta}

	~~ Handle `#navto abayar's laboratory`
	IF: Expr {(abayar's laboratory)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavSubway`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavSubway`, dictcreate[`destination`, `Abayar's Laboratory`]]}
				SetState {CallMeta}

	~~ Handle `#navto dark design`
	IF: Expr {(dark design)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavSubway`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavSubway`, dictcreate[`destination`, `Dark Design`]]}
				SetState {CallMeta}

	~~ Handle `#navto creepy canyons`
	IF: Expr {(creepy canyons)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavSubway`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavSubway`, dictcreate[`destination`, `Creepy Canyons`]]}
				SetState {CallMeta}

	~~ Handle `#navto thrungus hole`
	IF: Expr {(thrungus hole)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavSubway`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavSubway`, dictcreate[`destination`, `Thrungus Hole`]]}
				SetState {CallMeta}

	~~ Handle `#navto black death catacombs`
	IF: Expr {(black death catacombs)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavSubway`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavSubway`, dictcreate[`destination`, `Black Death Catacombs`]]}
				SetState {CallMeta}

	~~ Handle `#navto insatiable vault`
	IF: Expr {(insatiable vault)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavSubway`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavSubway`, dictcreate[`destination`, `Insatiable Vault`]]}
				SetState {CallMeta}

	~~ Handle `#navto ravenous vault`
	IF: Expr {(ravenous vault)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavSubway`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavSubway`, dictcreate[`destination`, `Ravenous Vault`]]}
				SetState {CallMeta}

	~~ Handle `#navto augmentation realm main level`
	IF: Expr {(augmentation realm main level)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavSubway`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavSubway`, dictcreate[`destination`, `Augmentation Realm Main Level`]]}
				SetState {CallMeta}

	~~ Handle `#navto obsidian rim`
	IF: Expr {(obsidian rim)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavSubway`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavSubway`, dictcreate[`destination`, `Obsidian Rim`]]}
				SetState {CallMeta}

	~~ Handle `#navto path of the blind`
	IF: Expr {(path of the blind)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavSubway`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavSubway`, dictcreate[`destination`, `Path of the Blind`]]}
				SetState {CallMeta}

	~~ Handle `#navto singularity bore`
	IF: Expr {(singularity bore)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavSubway`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavSubway`, dictcreate[`destination`, `Singularity Bore`]]}
				SetState {CallMeta}

	~~ Handle `#navto egg orchard`
	IF: Expr {(egg orchard)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavSubway`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavSubway`, dictcreate[`destination`, `Egg Orchard`]]}
				SetState {CallMeta}

	~~ Jungle Subway

	~~ Handle `#navto south direlands`
	IF: Expr {(south direlands)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavJungleSubway`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavJungleSubway`, dictcreate[`destination`, `South Direlands`]]}
				SetState {CallMeta}

	~~ Handle `#navto vissidal island`
	IF: Expr {(vissidal island)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavJungleSubway`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavJungleSubway`, dictcreate[`destination`, `Vissidal Island`]]}
				SetState {CallMeta}

	~~ Handle `#navto beach fort`
	IF: Expr {(beach fort)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavJungleSubway`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavJungleSubway`, dictcreate[`destination`, `Beach Fort`]]}
				SetState {CallMeta}

	~~ Handle `#navto black spawn den`
	IF: Expr {(black spawn den)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavJungleSubway`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavJungleSubway`, dictcreate[`destination`, `Black Spawn Den`]]}
				SetState {CallMeta}

	~~ Handle `#navto obsidian rim`
	IF: Expr {(obsidian rim)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavJungleSubway`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavJungleSubway`, dictcreate[`destination`, `Obsidian Rim`]]}
				SetState {CallMeta}

	~~ Handle `#navto north direlands`
	IF: Expr {(north direlands)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavJungleSubway`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavJungleSubway`, dictcreate[`destination`, `North Direlands`]]}
				SetState {CallMeta}

	~~ Handle `#navto crater pathway`
	IF: Expr {(crater pathway)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavJungleSubway`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavJungleSubway`, dictcreate[`destination`, `Crater Pathway`]]}
				SetState {CallMeta}

	~~ Handle `#navto dark isle`
	IF: Expr {(dark isle)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavJungleSubway`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavJungleSubway`, dictcreate[`destination`, `Dark Isle`]]}
				SetState {CallMeta}

	~~ Handle `#navto mukkir-infested black spear temple`
	IF: Expr {(mukkir infested black spear temple)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavJungleSubway`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavJungleSubway`, dictcreate[`destination`, `Mukkir-Infested Black Spear Temple`]]}
				SetState {CallMeta}

	~~ Handle `#navto the colosseum`
	IF: Expr {(the colosseum)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavJungleSubway`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavJungleSubway`, dictcreate[`destination`, `The Colosseum`]]}
				SetState {CallMeta}

	~~ Handle `#navto nexus`
	IF: Expr {(nexus)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavJungleSubway`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavJungleSubway`, dictcreate[`destination`, `Nexus`]]}
				SetState {CallMeta}

	~~ Handle `#navto mountain retreat`
	IF: Expr {(mountain retreat)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavJungleSubway`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavJungleSubway`, dictcreate[`destination`, `Mountain Retreat`]]}
				SetState {CallMeta}

	~~ Handle `#navto empyrean facility upper level`
	IF: Expr {(empyrean facility upper level)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavJungleSubway`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavJungleSubway`, dictcreate[`destination`, `Empyrean Facility Upper Level`]]}
				SetState {CallMeta}

	~~ Handle `#navto underground city`
	IF: Expr {(underground city)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavJungleSubway`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavJungleSubway`, dictcreate[`destination`, `Underground City`]]}
				SetState {CallMeta}

	~~ Handle `#navto northern aerlinthe island`
	IF: Expr {(northern aerlinthe island)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavJungleSubway`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavJungleSubway`, dictcreate[`destination`, `Northern Aerlinthe Island`]]}
				SetState {CallMeta}

	~~ Handle `#navto halls of metos`
	IF: Expr {(halls of metos)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavJungleSubway`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavJungleSubway`, dictcreate[`destination`, `Halls of Metos`]]}
				SetState {CallMeta}

	~~ Handle `#navto frozen valley camp`
	IF: Expr {(frozen valley camp)#getvar[capturegroup_navdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavJungleSubway`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavJungleSubway`, dictcreate[`destination`, `Frozen Valley Camp`]]}
				SetState {CallMeta}


	~~ Handle no match for navdestination
	IF: Expr {$LEVEL_WARN>=@CCDebug}
		DO: DoAll
				DoExpr {echo[`[WARN] No matching destination for #navto`, $COLOR_WARN]}
				SetState {Idle}

~~ }


STATE: {HandleQuests} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	IF: Expr {(help)#getvar[capturegroup_questdestination]}
		DO: DoAll
				DoExpr {echo[`#quest bloodstone investigation: Navigate to the quest Bloodstone Investigation`, $COLOR_INFO]}
				DoExpr {echo[`#quest count phainors amulet: Navigate to the quest Count Phainor's Amulet`, $COLOR_INFO]}
				DoExpr {echo[`#quest deewains: Navigate to the quest Deewain's Dark Cavern`, $COLOR_INFO]}
				DoExpr {echo[`#quest curator: Navigate to the quest Defeating the Curator of Torment`, $COLOR_INFO]}
				DoExpr {echo[`#quest dream reaver: Navigate to the quest Dream Reaver Investigation`, $COLOR_INFO]}
				DoExpr {echo[`#quest empyrean rescue: Navigate to the quest Empyrean Rescue`, $COLOR_INFO]}
				DoExpr {echo[`#quest end of days: Navigate to the quest End of Days`, $COLOR_INFO]}
				DoExpr {echo[`#quest fear factory: Navigate to the quest Fear Factory`, $COLOR_INFO]}
				DoExpr {echo[`#quest first sister: Navigate to the quest First Sister`, $COLOR_INFO]}
				DoExpr {echo[`#quest izexi: Navigate to the quest Foundry of Izexi`, $COLOR_INFO]}
				DoExpr {echo[`#quest four corners: Navigate to the quest Four Corners of Dereth`, $COLOR_INFO]}
				DoExpr {echo[`#quest geraines host: Navigate to the quest Geraine's Hosts`, $COLOR_INFO]}
				DoExpr {echo[`#quest geraines study: Navigate to the quest Geraine's Study`, $COLOR_INFO]}
				DoExpr {echo[`#quest gurog creation: Navigate to the quest Gurog Creation`, $COLOR_INFO]}
				DoExpr {echo[`#quest halt dericost: Navigate to the quest Halt Dericost Ritual`, $COLOR_INFO]}
				DoExpr {echo[`#quest hive queen: Navigate to the quest Hive Queen Assault`, $COLOR_INFO]}
				DoExpr {echo[`#quest hoshino fortress infiltration: Navigate to the quest Hoshino Fortress Infiltration`, $COLOR_INFO]}
				DoExpr {echo[`#quest hoshino must die: Navigate to the quest Hoshino Must Die`, $COLOR_INFO]}
				DoExpr {echo[`#quest janthefs: Navigate to the quest Janthef's Release`, $COLOR_INFO]}
				DoExpr {echo[`#quest liberation of uziz: Navigate to the quest Liberation of Uziz`, $COLOR_INFO]}
				DoExpr {echo[`#quest lost lore: Navigate to the quest Lost Lore`, $COLOR_INFO]}
				DoExpr {echo[`#quest lugian assault: Navigate to the quest Lugian Assault`, $COLOR_INFO]}
				DoExpr {echo[`#quest mhoire castle: Navigate to the quest Mhoire Castle`, $COLOR_INFO]}
				DoExpr {echo[`#quest nanjou stockade: Navigate to the quest Nanjou Stockade`, $COLOR_INFO]}
				DoExpr {echo[`#quest ninja academy: Navigate to the quest Ninja Academy`, $COLOR_INFO]}
				DoExpr {echo[`#quest oubliette: Navigate to the quest Oubliette of Mhoire Castle`, $COLOR_INFO]}
				DoExpr {echo[`#quest purging the corruption: Navigate to the quest Purging the Corruption`, $COLOR_INFO]}
				DoExpr {echo[`#quest releasing the light: Navigate to the quest Releasing the Light`, $COLOR_INFO]}
				DoExpr {echo[`#quest mouf p: Navigate to the quest Rescuing Mouf P`, $COLOR_INFO]}
				DoExpr {echo[`#quest rynthid foothold: Navigate to the quest Rynthid Foothold`, $COLOR_INFO]}
				DoExpr {echo[`#quest rynthid foundry: Navigate to the quest Rynthid Foundry`, $COLOR_INFO]}
				DoExpr {echo[`#quest rynthid training: Navigate to the quest Rynthid Training`, $COLOR_INFO]}
				DoExpr {echo[`#quest save karul: Navigate to the quest Save Karul`, $COLOR_INFO]}
				DoExpr {echo[`#quest second sister: Navigate to the quest Second Sister`, $COLOR_INFO]}
				DoExpr {echo[`#quest seed of power: Navigate to the quest Seed of Power`, $COLOR_INFO]}
				DoExpr {echo[`#quest serpent burial grounds: Navigate to the quest Serpent Burial Grounds`, $COLOR_INFO]}
				DoExpr {echo[`#quest shroud of emotion: Navigate to the quest Shroud of Emotion`, $COLOR_INFO]}
				DoExpr {echo[`#quest slave master: Navigate to the quest Slave Master`, $COLOR_INFO]}
				DoExpr {echo[`#quest tanada intercept: Navigate to the quest Tanada Intercept and Slaughter`, $COLOR_INFO]}
				DoExpr {echo[`#quest third sister: Navigate to the quest Third Sister`, $COLOR_INFO]}
				SetState {Idle}

	~~ Handle `#quest bloodstone investigation`
	IF: Expr {(bloodstone investigation)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `bloodstone investigation`]]}
				SetState {CallMeta}

	~~ Handle `#quest count phainors amulet`
	IF: Expr {(count phainors amulet)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `count phainors amulet`]]}
				SetState {CallMeta}

	~~ Handle `#quest deewains`
	IF: Expr {(deewains)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `deewains`]]}
				SetState {CallMeta}

	~~ Handle `#quest curator`
	IF: Expr {(curator)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `curator`]]}
				SetState {CallMeta}

	~~ Handle `#quest dream reaver`
	IF: Expr {(dream reaver)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `dream reaver`]]}
				SetState {CallMeta}

	~~ Handle `#quest empyrean rescue`
	IF: Expr {(empyrean rescue)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `empyrean rescue`]]}
				SetState {CallMeta}

	~~ Handle `#quest end of days`
	IF: Expr {(end of days)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `end of days`]]}
				SetState {CallMeta}

	~~ Handle `#quest fear factory`
	IF: Expr {(fear factory)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `fear factory`]]}
				SetState {CallMeta}

	~~ Handle `#quest first sister`
	IF: Expr {(first sister)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `first sister`]]}
				SetState {CallMeta}

	~~ Handle `#quest izexi`
	IF: Expr {(izexi)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `izexi`]]}
				SetState {CallMeta}

	~~ Handle `#quest four corners`
	IF: Expr {(four corners)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `four corners`]]}
				SetState {CallMeta}

	~~ Handle `#quest geraines host`
	IF: Expr {(geraines host)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavGerainesHosts`]}
				SetState {CallMeta}

	~~ Handle `#quest geraines study`
	IF: Expr {(geraines study)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `geraines study`]]}
				SetState {CallMeta}

	~~ Handle `#quest gurog creation`
	IF: Expr {(gurog creation)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `gurog creation`]]}
				SetState {CallMeta}

	~~ Handle `#quest halt dericost`
	IF: Expr {(halt dericost)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `halt dericost`]]}
				SetState {CallMeta}

	~~ Handle `#quest hive queen`
	IF: Expr {(hive queen)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `hive queen`]]}
				SetState {CallMeta}

	~~ Handle `#quest hoshino fortress`
	IF: Expr {(hoshino fortress)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `hoshino fortress`]]}
				SetState {CallMeta}

	~~ Handle `#quest hoshino must die`
	IF: Expr {(hoshino must die)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `hoshino must die`]]}
				SetState {CallMeta}

	~~ Handle `#quest janthefs`
	IF: Expr {(janthefs)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `janthefs`]]}
				SetState {CallMeta}

	~~ Handle `#quest liberation of uziz`
	IF: Expr {(liberation of uziz)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `liberation of uziz`]]}
				SetState {CallMeta}

	~~ Handle `#quest lost lore`
	IF: Expr {(lost lore)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `lost lore`]]}
				SetState {CallMeta}

	~~ Handle `#quest lugian assault`
	IF: Expr {(lugian assault)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `lugian assault`]]}
				SetState {CallMeta}

	~~ Handle `#quest mhoire castle`
	IF: Expr {(mhoire castle)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `mhoire castle`]]}
				SetState {CallMeta}

	~~ Handle `#quest nanjou stockade`
	IF: Expr {(nanjou stockade)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `nanjou stockade`]]}
				SetState {CallMeta}

	~~ Handle `#quest ninja academy`
	IF: Expr {(ninja academy)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `ninja academy`]]}
				SetState {CallMeta}

	~~ Handle `#quest oubliette`
	IF: Expr {(oubliette)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `oubliette`]]}
				SetState {CallMeta}

	~~ Handle `#quest purging the corruption`
	IF: Expr {(purging the corruption)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `purging the corruption`]]}
				SetState {CallMeta}

	~~ Handle `#quest releasing the light`
	IF: Expr {(releasing the light)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `releasing the light`]]}
				SetState {CallMeta}

	~~ Handle `#quest mouf p`
	IF: Expr {(mouf p)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `mouf p`]]}
				SetState {CallMeta}

	~~ Handle `#quest rynthid foothold`
	IF: Expr {(rynthid foothold)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `rynthid foothold`]]}
				SetState {CallMeta}

	~~ Handle `#quest rynthid foundry`
	IF: Expr {(rynthid foundry)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `rynthid foundry`]]}
				SetState {CallMeta}

	~~ Handle `#quest rynthid training`
	IF: Expr {(rynthid training)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `rynthid training`]]}
				SetState {CallMeta}

	~~ Handle `#quest save karul`
	IF: Expr {(save karul)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `save karul`]]}
				SetState {CallMeta}

	~~ Handle `#quest second sister`
	IF: Expr {(second sister)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `second sister`]]}
				SetState {CallMeta}

	~~ Handle `#quest seed of power`
	IF: Expr {(seed of power)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `seed of power`]]}
				SetState {CallMeta}

	~~ Handle `#quest serpent burial grounds`
	IF: Expr {(serpent burial grounds)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `serpent burial grounds`]]}
				SetState {CallMeta}

	~~ Handle `#quest shroud of emotion`
	IF: Expr {(shroud of emotion)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `shroud of emotion`]]}
				SetState {CallMeta}

	~~ Handle `#quest slave master`
	IF: Expr {(slave master)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `slave master`]]}
				SetState {CallMeta}

	~~ Handle `#quest tanada intercept`
	IF: Expr {(tanada intercept)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `tanada intercept`]]}
				SetState {CallMeta}

	~~ Handle `#quest third sister`
	IF: Expr {(third sister)#getvar[capturegroup_questdestination]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavQuest`]}
				DoExpr {$CCArguments=dictcreate[`CheCommandNavQuest`, dictcreate[`destination`, `third sister`]]}
				SetState {CallMeta}

	~~ Handle no match for questdestination
	IF: Expr {$LEVEL_WARN>=@CCDebug}
		DO: DoAll
				DoExpr {echo[`[WARN] No matching quest for #quest`, $COLOR_WARN]}
				SetState {Idle}

~~ }


STATE: {HandleRoute} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ No routes found, show warning
	IF: Expr {listcount[listfilter[dictkeys[$CCRoutes], `cstrf[getplayerlandcell[], \`X8\`]==$1`]]==0}
		DO: DoAll
				DoExpr {echo[`[WARN] No matching routes found for `+cstrf[getplayerlandcell[], `X8`], $COLOR_WARN]}
				SetState {Idle}

	~~ Route found, load route and start navigation
	IF: Expr {listcount[listfilter[dictkeys[$CCRoutes], `cstrf[getplayerlandcell[], \`X8\`]==$1`]]>0}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Loading route: \`+dictgetitem[$CCRoutes, cstrf[getplayerlandcell[], \`X8\`]]]`, `false`]}
				ChatExpr {`/vt nav load `+dictgetitem[$CCRoutes, cstrf[getplayerlandcell[], `X8`]]}
				DoExpr {@CCStay=true}
				DoExpr {uisetlabel[uigetcontrol[Main, Follow], `Follow`]}
				SetOpt {EnableNav} {True}
				SetOpt {NavPriorityBoost} {False}
				SetState {Idle}

~~ }


STATE: {HandleMetas} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Handle `#meta help`
	IF: Expr {(help)#getvar[capturegroup_metatext]}
		DO: DoAll
				~~ DoExpr {echo[`#meta: Loads the profile associated with the landcell`, $COLOR_INFO]}
				DoExpr {echo[`#meta add <nickname> <filename>: Adds the meta to the saved meta list`, $COLOR_INFO]}
				~~ DoExpr {echo[`#meta addlandcell <Profile Name>: Adds the profile with the current landcell to the auto load profile list`, $COLOR_INFO]}
				~~ DoExpr {echo[`#meta landcell: Shows the current profile for the landcell`, $COLOR_INFO]}
				DoExpr {echo[`#meta list: Lists all saved metas`, $COLOR_INFO]}
				DoExpr {echo[`#meta load <nickname>: Loads the nicknamed meta on all characters`, $COLOR_INFO]}
				DoExpr {echo[`#meta remove <nickname>: Removes the nicknamed meta on all characters`, $COLOR_INFO]}
				SetState {Idle}

	~~ Handle `#meta list` when it's empty
	IF: All
			Expr {listcount[@CCMetaValues]==0}
			Expr {(list)#getvar[capturegroup_metatext]}
		DO: DoAll
				DoExpr {echo[`No metas`, $COLOR_INFO]}
				SetState {Idle}

	~~ Handle `#meta list` if there are metas
	IF: All
			Expr {listcount[@CCMetaValues]>0}
			Expr {(list)#getvar[capturegroup_metatext]}
		DO: DoAll
				DoExpr {listmap[@CCMetaKeys, `echo[$1+\` => \`+listgetitem[@CCMetaValues, $0], $COLOR_INFO]`]}
				SetState {Idle}

~~ }


STATE: {MetaAdd} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Add an additional meta to an existing nickname
	IF: Expr {listindexof[@CCMetaKeys, $capturegroup_nickname]!=-1}
		DO: DoAll
				DoExpr {$id=listindexof[@CCMetaKeys, $capturegroup_nickname]}
				DoExpr {$metafilenames=listgetitem[@CCMetaValues, $id]}
				DoExpr {listadd[$metafilenames, $capturegroup_metafilename]}
				DoExpr {echo[`Added `+$capturegroup_nickname+` => `+listgetitem[@CCMetaValues, listindexof[@CCMetaKeys, $capturegroup_nickname]], $COLOR_INFO]}
				DoExpr {listmap[listcreate[`metafilenames`, `id`, `capturegroup_nickname`, `capturegroup_metafilename`], `clearvar[$1]`]}
				SetState {Idle}

	~~ Add a new meta nickname
	IF: Expr {listindexof[@CCMetaKeys, $capturegroup_nickname]==-1}
		DO: DoAll
				DoExpr {listadd[@CCMetaKeys, $capturegroup_nickname]}
				DoExpr {listadd[@CCMetaValues, listcreate[$capturegroup_metafilename]]}
				DoExpr {echo[`Added `+$capturegroup_nickname+` => `+listgetitem[@CCMetaValues, listindexof[@CCMetaKeys, $capturegroup_nickname]], $COLOR_INFO]}
				DoExpr {listmap[listcreate[`capturegroup_nickname`, `capturegroup_metafilename`], `clearvar[$1]`]}
				SetState {Idle}

~~ }


STATE: {MetaRemove} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Warn if nicknamed meta is not found
	IF: Expr {listindexof[@CCMetaKeys, $capturegroup_nickname]==-1}
		DO: DoAll
				DoExpr {echo[`[WARN] No meta found`, $COLOR_WARN]}
				DoExpr {clearvar[capturegroup_nickname]}
				SetState {Idle}

	~~ Remove the nicknamed meta
	IF: Expr {listindexof[@CCMetaKeys, $capturegroup_nickname]!=-1}
		DO: DoAll
				DoExpr {$id=listindexof[@CCMetaKeys, $capturegroup_nickname]}
				DoExpr {echo[`Removing `+$capturegroup_nickname+` => `+listgetitem[@CCMetaValues, $id], $COLOR_INFO]}
				DoExpr {listremoveat[@CCMetaKeys, $id]}
				DoExpr {listremoveat[@CCMetaValues, $id]}
				DoExpr {clearvar[capturegroup_nickname]}
				SetState {Idle}

~~ }


STATE: {MetaLoad} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Warn if nicknamed meta is not found
	IF: Expr {listindexof[@CCMetaKeys, $capturegroup_nickname]==-1}
		DO: DoAll
				DoExpr {echo[`[WARN] No meta found`, $COLOR_WARN]}
				DoExpr {clearvar[capturegroup_nickname]}
				SetState {Idle}

	~~ Turn on vitals if they are off
	IF: Expr {@CCVitals==false}
		DO: CallState {ToggleVitals} {MetaLoad}

	~~ load nicknamed meta(s)
	IF: Expr {listindexof[@CCMetaKeys, $capturegroup_nickname]!=-1}
		DO: DoAll
				DoExpr {$id=listindexof[@CCMetaKeys, $capturegroup_nickname]}
				DoExpr {$MetaCallQueue=listcopy[listgetitem[@CCMetaValues, $id]]}
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Loading meta(s) \`+listgetitem[@CCMetaValues, $id]]`, `false`]}
				DoExpr {listmap[listcreate[`id`, `capturegroup_nickname`, `capturegroup_metafilename`], `clearvar[$1]`]}
				SetState {CallMeta}

~~ }


STATE: {HandleProfile} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Handle `#profile help`
	IF: Expr {(help)#getvar[capturegroup_profiletext]}
		DO: DoAll
				DoExpr {echo[`#profile: Loads the profile associated with the landcell`, $COLOR_INFO]}
				DoExpr {echo[`#profile <Profile Nickname>: Loads the profile on all characters`, $COLOR_INFO]}
				DoExpr {echo[`#profile add <Profile Nickname> <Profile Filename>: Adds the profile to the saved profiles list`, $COLOR_INFO]}
				DoExpr {echo[`#profile addlandcell <Profile Name>: Adds the profile with the current landcell to the auto load profile list`, $COLOR_INFO]}
				DoExpr {echo[`#profile landcell: Shows the current profile for the landcell`, $COLOR_INFO]}
				DoExpr {echo[`#profile list: Lists all saved profiles`, $COLOR_INFO]}
				DoExpr {echo[`#profile load <Profile Nickname>: Loads the profile on all characters`, $COLOR_INFO]}
				SetState {Idle}

	~~ Warn if `#profile landcell` has no entry
	IF: All
			Expr {(landcell)#getvar[capturegroup_profiletext]}
			Expr {listindexof[@CCProfileLandcellKeys, cstrf[getplayerlandcell[], `X8`]]==-1}
		DO: DoAll
				DoExpr {echo[`[WARN] No profile found for landcell `+cstrf[getplayerlandcell[], `X8`], $COLOR_WARN]}
				SetState {Idle}

	~~ Show `#profile landcell` value
	IF: All
			Expr {(landcell)#getvar[capturegroup_profiletext]}
			Expr {listindexof[@CCProfileLandcellKeys, cstrf[getplayerlandcell[], `X8`]]!=-1}
		DO: DoAll
				DoExpr {$id=listindexof[@CCProfileLandcellKeys, cstrf[getplayerlandcell[], `X8`]]}
				DoExpr {echo[cstrf[getplayerlandcell[], `X8`]+` => `+listgetitem[@CCProfileLandcellValues, $id], $COLOR_INFO]}
				SetState {Idle}

	~~ Show `#profile list` values
	IF: Expr {(list)#getvar[capturegroup_profiletext]}
		DO: DoAll
				DoExpr {listmap[@CCProfileKeys, `echo[$1+\` => \`+listgetitem[@CCProfileValues, $0], $COLOR_INFO]`]}
				SetState {Idle}


	~~ Handle no match for profiletext
	IF: Expr {$LEVEL_WARN>=@CCDebug}
		DO: DoAll
				DoExpr {echo[`[WARN] No matching argument for #profile`, $COLOR_WARN]}
				SetState {Idle}

~~ }

STATE: {ProfileAdd} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Add a profile
	IF: Always
		DO: DoAll
				DoExpr {listadd[@CCProfileKeys, $capturegroup_profilename]}
				DoExpr {listadd[@CCProfileValues, $capturegroup_profilevalue]}
				DoExpr {echo[`Added `+$capturegroup_profilename+` => `+$capturegroup_profilevalue, $COLOR_INFO]}
				SetState {Idle}

~~ }


STATE: {ProfileLoad} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Close the Profiles view if open
	IF: Expr {uiviewvisible[Profiles]}
		DO: DestroyView {Profiles}

	~~ Warn if no profile found
	IF: Expr {listindexof[@CCProfileKeys, $capturegroup_profilename]==-1}
		DO: DoAll
				DoExpr {echo[`[WARN] No profile found`, $COLOR_WARN]}
				SetState {Idle}

	~~ Turn on vitals if they are off
	IF: Expr {@CCVitals==false}
		DO: CallState {ToggleVitals} {ProfileLoad}

	~~ load profile
	IF: Expr {listindexof[@CCProfileKeys, $capturegroup_profilename]!=-1}
		DO: DoAll
				DoExpr {$id=listindexof[@CCProfileKeys, $capturegroup_profilename]}
				ChatExpr {`/vt settings loadchar `+listgetitem[@CCProfileValues, $id]}
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Loaded profile \`+listgetitem[@CCProfileValues, $id]]`, `false`]}
				SetState {Idle}

~~ }


STATE: {ProfileAddLandcell} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Add a profile for a landcell
	IF: Always
		DO: DoAll
				DoExpr {listadd[@CCProfileLandcellKeys, cstrf[getplayerlandcell[], `X8`]]}
				DoExpr {listadd[@CCProfileLandcellValues, $capturegroup_profilename]}
				DoExpr {echo[`Added `+cstrf[getplayerlandcell[], `X8`]+` => `+$capturegroup_profilename, $COLOR_INFO]}
				SetState {Idle}

~~ }


STATE: {AutoloadProfile} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Warn if landcell has no entry
	IF: Expr {listindexof[@CCProfileLandcellKeys, cstrf[getplayerlandcell[], `X8`]]==-1}
		DO: DoAll
				DoExpr {echo[`[WARN] No profile found for landcell `+cstrf[getplayerlandcell[], `X8`], $COLOR_WARN]}
				SetState {Idle}

	~~ Load profile for landcell
	IF: Expr {listindexof[@CCProfileLandcellKeys, cstrf[getplayerlandcell[], `X8`]]!=-1}
		DO: DoAll
				DoExpr {$id=listindexof[@CCProfileLandcellKeys, cstrf[getplayerlandcell[], `X8`]]}
				DoExpr {$nickname=listgetitem[@CCProfileLandcellValues, $id]}
				DoExpr {$nid=listindexof[@CCProfileKeys, $nickname]}
				ChatExpr {`/vt settings loadchar `+listgetitem[@CCProfileValues, $nid]}
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Loaded profile \`+listgetitem[@CCProfileValues, $nid]]`, `false`]}
				SetState {Idle}

~~ }


STATE: {HandleKilltask} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	IF: Expr {(help)#getvar[capturegroup_flagaction]}
		DO: DoAll
				DoExpr {echo[`#killtask frozen valley: Flags with all NPCs in Frozen Valley`, $COLOR_INFO]}
				DoExpr {echo[`#killtask hoshino: Flags with all NPCs in Hoshino`, $COLOR_INFO]}
				DoExpr {echo[`#killtask vr: Flags with all NPCs in Viridian Rise`, $COLOR_INFO]}
				DoExpr {echo[`#killtask neftet: Flags with all NPCs in Neftet`, $COLOR_INFO]}
				DoExpr {echo[`#killtask rynthid: Flags with all NPCs in Rynthid`, $COLOR_INFO]}
				SetState {Idle}

	~~ Handle `#flag frozen valley`
	IF: Expr {(frozen valley)#getvar[capturegroup_flagaction]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavFrozenValley`]}
				DoExpr {listadd[$MetaCallQueue, `CheCommandKillTaskFlagFrozenValley`]}
				SetState {CallMeta}

	~~ Handle `#flag neftet`
	IF: Expr {(neftet)#getvar[capturegroup_flagaction]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavNeftet`]}
				DoExpr {listadd[$MetaCallQueue, `CheCommandKillTaskFlagNeftet`]}
				SetState {CallMeta}

	~~ Handle `#flag rynthid`
	IF: Expr {(rynthid)#getvar[capturegroup_flagaction]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandKillTaskFlagRynthid`]}
				SetState {CallMeta}

	~~ Handle `#flag hoshino`
	IF: Expr {(hoshino)#getvar[capturegroup_flagaction]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandNavHoshino`]}
				DoExpr {listadd[$MetaCallQueue, `CheCommandKillTaskFlagHoshino`]}
				SetState {CallMeta}

	~~ Handle `#flag hoshino`
	IF: Expr {(vr)#getvar[capturegroup_flagaction]}
		DO:	DoAll
				DoExpr {listadd[$MetaCallQueue, `CheCommandKillTaskFlagVR`]}
				SetState {CallMeta}

	~~ Handle no match for flagaction
	IF: Expr {$LEVEL_WARN>=@CCDebug}
		DO: DoAll
				DoExpr {echo[`[WARN] No matching action for #flag`, $COLOR_WARN]}
				SetState {Idle}

~~ }


STATE: {HandleLootingInfo} ~~ {

	~~ IF: Expr {(auto)#getvar[capturegroup_loottext]}
	~~ 	DO: SetState {AutoLoot}

	IF: Expr {(help)#getvar[capturegroup_loottext]}
		DO: DoAll
				DoExpr {echo[`#loot: Automatically loot items from corpses for many legendary quests.`, $COLOR_INFO]}
				DoExpr {echo[`#loot <item name> from <corpse name>: Loot the item from a corpse on all characters.`, $COLOR_INFO]}
				SetState {Idle}

~~ }


STATE: {HandleLooting} ~~ {

	IF: Always
		DO: DoAll
				DoExpr {$LootCorpseItem=$capturegroup_item}
				DoExpr {$LootCorpseName=$capturegroup_corpse}
				SetState {Loot}

~~ }


STATE: {HandleFace} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Handle `#check help`
	IF: Expr {(help)#getvar[capturegroup_facedirection]}
		DO: DoAll
				DoExpr {echo[`#face north`, $COLOR_INFO]}
				DoExpr {echo[`#face south`, $COLOR_INFO]}
				DoExpr {echo[`#face east`, $COLOR_INFO]}
				DoExpr {echo[`#face west`, $COLOR_INFO]}
				DoExpr {echo[`#face northeast`, $COLOR_INFO]}
				DoExpr {echo[`#face northwest`, $COLOR_INFO]}
				DoExpr {echo[`#face southeast`, $COLOR_INFO]}
				DoExpr {echo[`#face southwest`, $COLOR_INFO]}
				DoExpr {echo[`#face <heading>: Face in a specific heading`, $COLOR_INFO]}
				SetState {Idle}

	IF: Expr {(north)#getvar[capturegroup_facedirection]}
		DO: DoAll
				DoExpr {$direction=`0`}
				SetState {Face}

	IF: Expr {(south)#getvar[capturegroup_facedirection]}
		DO: DoAll
				DoExpr {$direction=`180`}
				SetState {Face}

	IF: Expr {(east)#getvar[capturegroup_facedirection]}
		DO: DoAll
				DoExpr {$direction=`90`}
				SetState {Face}

	IF: Expr {(west)#getvar[capturegroup_facedirection]}
		DO: DoAll
				DoExpr {$direction=`270`}
				SetState {Face}

	IF: Expr {(northeast)#getvar[capturegroup_facedirection]}
		DO: DoAll
				DoExpr {$direction=`45`}
				SetState {Face}

	IF: Expr {(northwest)#getvar[capturegroup_facedirection]}
		DO: DoAll
				DoExpr {$direction=`315`}
				SetState {Face}

	IF: Expr {(southeast)#getvar[capturegroup_facedirection]}
		DO: DoAll
				DoExpr {$direction=`135`}
				SetState {Face}

	IF: Expr {(southwest)#getvar[capturegroup_facedirection]}
		DO: DoAll
				DoExpr {$direction=`225`}
				SetState {Face}

	IF: Always
		DO: DoAll
				DoExpr {$direction=$capturegroup_facedirection}
				SetState {Face}

~~ }


STATE: {Face} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Disable all options
	IF: Expr {testvar[OptionsSet]==false}
		DO: CallState {DisableOptions} {Face}

	IF:	ChatMatch {^You think, "Turning Success"}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Finished turning\`]`, `false`]}
				DoExpr {clearvar[direction]}
				CallState {EnableOptions} {Idle}

	IF:	ChatMatch {^You think, "Turning failed"}
		DO: SetState {Face}

	IF: Always
		DO: ChatExpr {`/ub face `+$direction}

~~ }


STATE: {HandleJumping} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Handle `#jump tap`
	IF: Expr {(tap)#getvar[capturegroup_jumptext]}
		DO: DoAll
				DoExpr {$Jumptext=`sw 250`}
				SetState {Jump}

	~~ Handle `#jump stack` for issuer
	IF: All
			Expr {$capturegroup_name==false}
			Expr {(stack)#getvar[capturegroup_jumptext]}
		DO: SetState {Idle}

	~~ Handle `#jump stack` for followers
	IF: All
			Expr {$capturegroup_name!=false}
			Expr {(stack)#getvar[capturegroup_jumptext]}
		DO: SetState {JumpStack}

	~~ Handle `#jump <jumptext>`
	IF: Always
		DO: DoAll
				DoExpr {$Jumptext=$capturegroup_jumptext}
				SetState {Jump}

~~ }


STATE: {Jump} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Disable all options
	IF: Expr {testvar[OptionsSet]==false}
		DO: CallState {DisableOptions} {Jump}

	~~ Try jumping
	IF: Always
		DO: ChatExpr {`/ub jump`+$Jumptext}

	~~ Jump success
	IF:	ChatMatch {^You think, "Jumper Success"}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Finished jumping\`]`, `false`]}
				CallState {EnableOptions} {Idle}

	~~ Jump failure
	IF:	ChatMatch {^You think, "You have failed to jump too many times}
		DO:	SetState {Jump}

~~ }


STATE: {JumpStack} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	DoAll
				DoExpr {listmap[listcreate[`OriginalNavClosestOpRange`, `OriginalNavPriorityBoost`, `capturegroup_name`, `capturegroup_jumptext`], `clearvar[$1]`]}
				SetState {Idle}

	~~ Save settings and set NavClosestOpRange to get on top of issuer
	IF: Expr {testvar[OriginalNavClosestOpRange]==false}
		DO: DoAll
				DoExpr {setvar[OriginalNavClosestOpRange, vtgetsetting[NavClosestOpRange]]}
				DoExpr {vtsetsetting[NavClosestOpRange, cstrf[@CCOnMeThreshold/240, `N8`]]}
				DoExpr {setvar[OriginalNavPriorityBoost, vtgetsetting[NavPriorityBoost]]}
				DoExpr {vtsetsetting[NavPriorityBoost, `true`]}
				ChatExpr {`/ub follow `+$capturegroup_name}
				SetState {JumpStack}

	~~ Finish if on top of the issuer
	IF: Expr {coordinatedistancewithz[wobjectgetphysicscoordinates[wobjectfindnearestbynameandobjectclass[$PLAYER, $capturegroup_name]], getplayercoordinates[]]<=@CCOnMeThreshold}
		DO: DoAll
				DoExpr {echo[`Original NavClosestOpRange: `+$OriginalNavClosestOpRange, $COLOR_DEBUG]}
				DoExpr {vtsetsetting[NavClosestOpRange, cstrf[$OriginalNavClosestOpRange, `N8`]]}
				DoExpr {vtsetsetting[NavPriorityBoost, cstrf[$OriginalNavPriorityBoost, `N0`]]}
				EmbedNav Empty {[None]}
				DoExpr {ifthen[@CCStay==false, `chatbox[\`/ub follow \`+@CCLeader]`, `false`]}
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Finished navigating on top of \`+$capturegroup_name]`, `false`]}
				DoExpr {listmap[listcreate[`OriginalNavClosestOpRange`, `OriginalNavPriorityBoost`, `capturegroup_name`, `capturegroup_jumptext`], `clearvar[$1]`]}
				SetState {Idle}

~~ }


STATE: {HandlePickup} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	IF: Always
		DO: DoAll
				DoExpr {$item=$capturegroup_itemtext}
				SetState {Pickup}

~~ }


STATE: {Pickup} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	DoAll
				DoExpr {listmap[listcreate[`itemCount`, `item`, `hasNearbyItem`], `clearvar[$1]`]}
				SetState {Idle}

	~~ Disable all options
	IF: Expr {testvar[OptionsSet]==false}
		DO: CallState {DisableOptions} {Pickup}

	~~ Enter Peace mode
	IF: Expr {getcombatstate[]!=`Peace`}
		DO: DoAll
				DoExpr {setcombatstate[peace]}
				SetState {Pickup}

	~~ Set the amount of items you have
	IF: Expr {testvar[itemCount]==false}
		DO: DoExpr {$itemCount=getitemcountininventorybynamerx[$item]}

	~~ Handle no items nearby
	IF: All
			Expr {testvar[hasNearbyItem]==false]}
			Expr {listcount[wobjectfindalllandscapebynamerx[$item]]==0}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, No \`+$item+\` nearby\`]`, `false`]}
				DoExpr {listmap[listcreate[`itemCount`, `item`, `hasNearbyItem`], `clearvar[$1]`]}
				CallState {EnableOptions} {Idle}

	~~ Stop picking up if your items are above the initial value or ChatMatch
	IF: Any
			Expr {getitemcountininventorybynamerx[$item]>$itemCount}
			ChatMatch {You have solved}
			ChatMatch {You cannot pick up more than}
			ChatMatch {You must wait}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Picked up \`+$item]`, `false`]}
				DoExpr {listmap[listcreate[`itemCount`, `item`, `hasNearbyItem`], `clearvar[$1]`]}
				CallState {EnableOptions} {Idle}

	~~ Pickup the item from the landscape
	IF: All
			Expr {listcount[wobjectfindalllandscapebynamerx[$item]]>0}
			Expr {getitemcountininventorybynamerx[$item]==$itemCount}
		DO: DoAll
				DoExpr {actiontryuseitem[listpop[wobjectfindalllandscapebynamerx[$item], 0]]}
				DoExpr {setvar[hasNearbyItem, true]}
				SetState {Pickup}

~~ }


STATE: {HandleGive} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	DoAll
				DoExpr {listmap[listcreate[`capturegroup_itemtext`, `capturegroup_giveto`, `capturegroup_name`, `capturegroup_saythink`], `clearvar[$1]`]}
				SetState {Idle}

	IF: Expr {(help)#getvar[capturegroup_itemtext]}
		DO: DoAll
				DoExpr {echo[`#give <item name> to <person name>: All characters give the item in inventory to the person.`, $COLOR_INFO]}
				DoExpr {echo[`#give <item name>: All characters give the item in inventory to the person who issued the command.`, $COLOR_INFO]}
				DoExpr {listmap[listcreate[`capturegroup_itemtext`, `capturegroup_giveto`, `capturegroup_name`, `capturegroup_saythink`], `clearvar[$1]`]}
				SetState {Idle}

	~~ If the optional match for giveto is empty set it to the person who issued the command
	IF: Expr {testvar[capturegroup_giveto]==false}
		DO: DoExpr {$capturegroup_giveto=ifthen[$capturegroup_name, `$capturegroup_name`, `$CHARACTER_NAME`]}

	~~ If giveto is your character you don't need to do anything
	IF: Expr {$capturegroup_giveto==$CHARACTER_NAME}
		DO: DoAll
				DoExpr {listmap[listcreate[`capturegroup_itemtext`, `capturegroup_giveto`, `capturegroup_name`, `capturegroup_saythink`], `clearvar[$1]`]}
				SetState {Idle}

	~~ Set the $item and $name and clear variables
	IF: Always
		DO: DoAll
				DoExpr {$item=$capturegroup_itemtext}
				DoExpr {$name=$capturegroup_giveto}
				DoExpr {listmap[listcreate[`capturegroup_itemtext`, `capturegroup_giveto`, `capturegroup_name`, `capturegroup_saythink`], `clearvar[$1]`]}
				SetState {Give}

~~ }


STATE: {AutoGive} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	DoAll
				DoExpr {listmap[listcreate[`item`, `name`], `clearvar[$1]`]}
				SetState {Idle}

	~~ No NPC nearby with the Autogive name
	IF: Not Expr {dicthaskey[$AUTOGIVE_PROFILE, wobjectgetname[wobjectfindnearestbyobjectclass[$NPC]]]}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, No autogive profile for \`+wobjectgetname[wobjectfindnearestbyobjectclass[$NPC]]]`, `false`]}
				DoExpr {listmap[listcreate[`item`, `name`], `clearvar[$1]`]}
				SetState {Idle}

	~~ Found NPC hand off to Give
	IF: Expr {dicthaskey[$AUTOGIVE_PROFILE, wobjectgetname[wobjectfindnearestbyobjectclass[$NPC]]]}
		DO: DoAll
				DoExpr {$name=wobjectgetname[wobjectfindnearestbyobjectclass[$NPC]]}
				DoExpr {$item=dictgetitem[$AUTOGIVE_PROFILE, $name]}
				SetState {Give}

~~ }


STATE: {Give} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	DoAll
				DoExpr {listmap[listcreate[`item`, `name`], `clearvar[$1]`]}
				SetState {Idle}

	~~ Disable all options
	IF: Expr {testvar[OptionsSet]==false}
		DO: CallState {DisableOptions} {Give}

	~~ If set equip item before giving
	IF: Expr {@CCEquipOnTurnin!=false}
		DO: DoAll
				DoExpr {actiontryuseitem[@CCEquipOnTurnin]}

	~~ Warn if unable to give
	IF: ChatMatch {doesn't know what to do with that.$}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Unable to give \`+$item]`, `false`]}
				DoExpr {listmap[listcreate[`item`, `name`], `clearvar[$1]`]}
				CallState {EnableOptions} {Idle}

	~~ Successfully handed off item
	IF: Any
			ChatMatch {^You give}
			ChatMatch {^You hand over}
			ChatMatch {^You allow}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Gave \`+$item]`, `false`]}
				DoExpr {listmap[listcreate[`item`, `name`], `clearvar[$1]`]}
				CallState {EnableOptions} {Idle}

	~~ Handle $item being a list
	IF: Expr {getobjectinternaltype[$item]==$TYPE_OBJECT}
		DO: DoAll
				DoExpr {$hasItems=listfilter[$item, `wobjectfindininventorybynamerx[\`^\`+$1+\`$\`]`]}
				DoExpr {$item=ifthen[listcount[$hasItems]>=1, `listpop[$hasItems, 0]`, `false`]}
				SetState {Give}

	~~ Missing item
	IF: All
			SecsInStateGE 1
			Expr {wobjectfindininventorybynamerx[`^`+$item+`$`]==false}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, I do not have \`+$item]`, `false`]}
				DoExpr {listmap[listcreate[`item`, `name`], `clearvar[$1]`]}
				CallState {EnableOptions} {Idle}

	~~ Give to nearest Player
	IF: All
			Expr {getobjectinternaltype[wobjectfindininventorybynamerx[`^`+$item+`$`]]==$TYPE_OBJECT}
			Expr {getobjectinternaltype[wobjectfindnearestbynameandobjectclass[$PLAYER, $name]]==$TYPE_OBJECT}
		DO: DoAll
				DoExpr {actiontrygiveitem[wobjectfindininventorybynamerx[`^`+$item+`$`], wobjectfindnearestbynameandobjectclass[$PLAYER, $name]]}
				SetState {Give}

	~~ Give to nearest NPC
	IF: All
			Expr {getobjectinternaltype[wobjectfindininventorybynamerx[`^`+$item+`$`]]==$TYPE_OBJECT}
			Expr {getobjectinternaltype[wobjectfindnearestbynameandobjectclass[$NPC, $name]]==$TYPE_OBJECT}
		DO: DoAll
				DoExpr {actiontrygiveitem[wobjectfindininventorybynamerx[`^`+$item+`$`], wobjectfindnearestbynameandobjectclass[$NPC, $name]]}
				SetState {Give}

	~~ Handle no player or NPC with that name nearby
	IF: Expr {wobjectfindnearestbynameandobjectclass[$PLAYER, $name]==false&&wobjectfindnearestbynameandobjectclass[$NPC, $name]==false}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, I can't find \`+$name]`, `false`]}
				DoExpr {listmap[listcreate[`item`, `name`], `clearvar[$1]`]}
				CallState {EnableOptions} {Idle}

~~ }


STATE: {HandleTrash} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	IF: Expr {(help)#getvar[capturegroup_trashtext]}
		DO: DoAll
				DoExpr {echo[`#trash: All characters give all trash items in inventory to a garabage barrel.`, $COLOR_INFO]}
				DoExpr {echo[`#trash <item name>: All characters give the item in inventory to garabage barrel.`, $COLOR_INFO]}
				DoExpr {listmap[listcreate[`capturegroup_trashtext`, `capturegroup_name`, `capturegroup_saythink`], `clearvar[$1]`]}
				SetState {Idle}

	~~ If the optional trashtext is not set, dispatch to AutoTrash state
	IF: Expr {testvar[capturegroup_trashtext]==false}
		DO: DoAll
				DoExpr {listmap[listcreate[`capturegroup_trashtext`, `capturegroup_name`, `capturegroup_saythink`], `clearvar[$1]`]}
				SetState {AutoTrash}

	~~ Warn if you do not have item
	IF: All
			Expr {testvar[capturegroup_trashtext]==true}
			Expr {wobjectfindininventorybyname[$capturegroup_trashtext]==false}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, I do not have \`+$capturegroup_trashtext]`, `false`]}
				DoExpr {listmap[listcreate[`capturegroup_trashtext`, `capturegroup_name`, `capturegroup_saythink`], `clearvar[$1]`]}
				SetState {Idle}

	~~ If the optional trashtext is set, dispatch to GiveTrash state
	IF: Expr {testvar[capturegroup_trashtext]==true}
		DO: DoAll
				DoExpr {$items=listcreate[$capturegroup_trashtext]}
				DoExpr {listmap[listcreate[`capturegroup_trashtext`, `capturegroup_name`, `capturegroup_saythink`], `clearvar[$1]`]}
				SetState {GiveTrash}

~~ }


STATE: {AutoTrash} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Find the trash items the character has in inventory
	IF: Always
		DO: DoAll
				DoExpr {$items=listfilter[$AUTO_TRASH_ITEMS, `getitemcountininventorybyname[$1]>0`]}

	~~ Abort if no trash items
	IF: Expr {listcount[$items]==0}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, I have no trash!\`]`, `false`]}
				DoExpr {clearvar[items]}
				SetState {Idle}

	~~ Go to GiveTrash state if there are items
	IF: Expr {listcount[$items]>0}
		DO: SetState {GiveTrash}

~~ }


STATE: {GiveTrash} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	DoAll
				DoExpr {listmap[listcreate[`item`, `items`, `giving`, `trashNPC`], `clearvar[$1]`]}
				SetState {Idle}

	~~ If a Garbage Barrel is nearby set $trashNPC to it
	IF: All
			Expr {testvar[trashNPC]==false}
			Expr {getobjectinternaltype[wobjectfindnearestbynameandobjectclass[$NPC, `Garbage Barrel`]]==$OBJECT}
			Expr {coordinatedistancewithz[wobjectgetphysicscoordinates[wobjectfindnearestbynameandobjectclass[$NPC, `Garbage Barrel`]],getplayercoordinates[]]<@CCTrashDistance}
		DO: DoExpr {$trashNPC=wobjectfindnearestbynameandobjectclass[$NPC, `Garbage Barrel`]}

	~~ If a Town Crier is nearby set $trashNPC to it
	IF: All
			Expr {testvar[trashNPC]==false}
			Expr {getobjectinternaltype[wobjectfindnearestbynameandobjectclass[$NPC, `Town Crier`]]==$OBJECT}
			Expr {coordinatedistancewithz[wobjectgetphysicscoordinates[wobjectfindnearestbynameandobjectclass[$NPC, `Town Crier`]],getplayercoordinates[]]<@CCTrashDistance}
		DO: DoExpr {$trashNPC=wobjectfindnearestbynameandobjectclass[$NPC, `Town Crier`]}

	~~ Warn if no Town Criers or Garbage Barrels nearby
	IF: Expr {testvar[trashNPC]==false}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, There are no Town Criers or Garbage Barrels nearby!\`]`, `false`]}
				DoExpr {listmap[listcreate[`item`, `items`, `giving`, `trashNPC`], `clearvar[$1]`]}
				SetState {Idle}

	~~ Get first item
	IF: Expr {testvar[item]==false}
		DO: DoExpr {$item=listpop[$items]}

	~~ Finished giving all items
	IF: All
			Expr {testvar[giving]==true}
			Expr {listcount[$items]==0}
			Expr {getitemcountininventorybyname[$item]==0}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, I gave all my trash!\`]`, `false`]}
				DoExpr {listmap[listcreate[`item`, `items`, `giving`, `trashNPC`], `clearvar[$1]`]}
				SetState {Idle}

	~~ Gave items
	IF: All
			ChatMatch {^You give}
			Expr {getitemcountininventorybyname[$item]==0}
		DO: DoAll
				DoExpr {$item=listpop[$items]}
				DoExpr {$giving=false}
				SetState {GiveTrash}

	~~ Give Item to $trashNPC
	IF: Always
		DO: DoAll
				DoExpr {actiontrygiveitem[wobjectfindininventorybyname[$item], $trashNPC]}
				DoExpr {$giving=true}
				SetState {GiveTrash}

~~ }


STATE: {HandlePass} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	DoAll
				DoExpr {listmap[listcreate[`item`, `capturegroup_passtext`, `capturegroup_name`, `capturegroup_saythink`], `clearvar[$1]`]}
				SetState {Idle}

	IF: Always
		DO: DoExpr {$item=$capturegroup_passtext}

	~~ Handle `#pass` for followers
	IF:	Expr {$capturegroup_name!=false}
		DO:	DoAll
				DoExpr {listmap[listcreate[`capturegroup_passtext`, `capturegroup_name`, `capturegroup_saythink`], `clearvar[$1]`]}
				SetState {PassWait}

	~~ Handle `#pass` for person who issued command
	IF:	Expr {$capturegroup_name==false}
		DO:	DoAll
				DoExpr {listmap[listcreate[`capturegroup_passtext`, `capturegroup_name`, `capturegroup_saythink`], `clearvar[$1]`]}
				SetState {PassGive}

~~ }


STATE: {PassWait} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	DoAll
				DoExpr {listmap[listcreate[`item`], `clearvar[$1]`]}
				SetState {Idle}

	~~ Use the item when given
	IF: ChatMatch {gives you}
		DO: DoAll
				DoExpr {actiontryuseitem[listgetitem[wobjectfindallinventorybynamerx[$item], 0]]}
				SetState {PassGive}

~~ }


STATE: {PassGive} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	DoAll
				DoExpr {listmap[listcreate[`onlineCharacters`, `sortedCharacters`, `currentPos`, `nextPos`, `nextCharacter`, `giving`, `item`], `clearvar[$1]`]}
				SetState {Idle}

	~~ Warn if no item found
	IF: All
			Expr {testvar[giving]==false}
			Expr {listcount[wobjectfindallinventorybynamerx[$item]]==0}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, I do not have \`+$item]`, `false`]}
				DoExpr {listmap[listcreate[`onlineCharacters`, `sortedCharacters`, `currentPos`, `nextPos`, `nextCharacter`, `giving`, `item`], `clearvar[$1]`]}
				SetState {Idle}

	~~ Pass to next person in the @CCCharacterList
	IF: Expr {listcount[wobjectfindallinventorybynamerx[$item]]>0}
		DO: DoAll
				DoExpr {$onlineCharacters=listfilter[@CCCharacterList, `$1==$CHARACTER_NAME||getobjectinternaltype[wobjectfindnearestbynameandobjectclass[$PLAYER, $1]]==$TYPE_OBJECT`]}
				DoExpr {$sortedCharacters=listsort[$onlineCharacters]} ~~ Sort to ensure all character lists are identical in order
				DoExpr {$currentPos=listindexof[$sortedCharacters, $CHARACTER_NAME]}
				DoExpr {$nextPos=ifthen[$currentPos+1>listcount[$sortedCharacters]-1, `0`, `$currentPos+1`]}
				DoExpr {$nextCharacter=listgetitem[$sortedCharacters, $nextPos]}
				DoExpr {$giving=true}
				DoExpr {actiontrygiveitem[listgetitem[wobjectfindallinventorybynamerx[$item], 0], wobjectfindnearestbynameandobjectclass[$PLAYER, $nextCharacter]]}
				SetState {PassGive}

	~~ Handed off item
	IF: ChatMatch {^You give}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Gave \`+$item]`, `false`]}
				DoExpr {listmap[listcreate[`onlineCharacters`, `sortedCharacters`, `currentPos`, `nextPos`, `nextCharacter`, `giving`, `item`], `clearvar[$1]`]}
				SetState {Idle}

~~ }


STATE: {HandleUse} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Handle `#use help`
	IF: Expr {(help)#getvar[capturegroup_usetext]}
		DO: DoAll
				DoExpr {echo[`#use help: Displays this help message`, $COLOR_INFO]}
				DoExpr {echo[`#use <item name>: All characters use the item`, $COLOR_INFO]}
				SetState {Idle}

	~~ Use item
	IF: Always
		DO: DoAll
				DoExpr {setvar[ItemName, $capturegroup_usetext]}
				DoExpr {clearvar[capturegroup_usetext]}
				SetState {Use}

~~ }


STATE: {Use} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Check to see if item is on the landscape
	IF: Expr {listcount[wobjectfindalllandscapebynamerx[`^`+$ItemName+`$`]]>0}
		DO: DoExpr {setvar[Item, listpop[wobjectfindalllandscapebynamerx[$ItemName]]]}

	~~ Check to see if item is in inventory
	IF: Expr {listcount[wobjectfindallinventorybynamerx[`^`+$ItemName+`$`]]>0}
		DO: DoExpr {setvar[Item, listpop[wobjectfindallinventorybynamerx[$ItemName]]]}

	~~ Warn if no item found
	IF: Expr {testvar[Item]==false}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Item to use not found!\`]`, `false`]}
				SetState {Idle}

	~~ If inventory item use it
	IF: All
			Expr {testvar[Item]==true}
			Expr {listcount[wobjectfindallinventorybynamerx[`^`+$ItemName+`$`]]>0}
		DO: SetState {UseInventory}

	~~ If landscape item use it
	IF: All
			Expr {testvar[Item]==true}
			Expr {listcount[wobjectfindalllandscapebynamerx[`^`+$ItemName+`$`]]>0}
		DO: SetState {UseLandscape}

~~ }


STATE: {UseInventory} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Use inventory item a single time since we won't get feedback
	IF: Always
		DO: DoAll
				DoExpr {actiontryuseitem[$Item]}
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Finished using \`+$ItemName]`, `false`]}
				DoExpr {listmap[listcreate[`Item`, `ItemName`], `clearvar[$1]`]}
				SetState {Idle}

~~ }


STATE: {UseLandscape} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Disable all options
	IF: Expr {testvar[OptionsSet]==false}
		DO: CallState {DisableOptions} {UseLandscape}

	~~ Stop using Item if you receieve a response
	IF:	Any
			All
				ChatCapture {.*} {0}  ~~ Directbroadcast of any kind
				Expr {$capturegroup_color==0}
			All
				ChatCapture {^(?<tellname>.*?) tells you, \"(?<npctext>.*)\"$} {}
				Expr {$capturegroup_tellname==$Item}
			All
				ChatCapture {^(?<tellname>.*?) gives you (?<npctext>.*)$} {}
				Expr {$capturegroup_tellname==$Item}
			All
				ChatCapture {^(?<tellname>.*?) cast (?<npctext>.*)$} {}
				Expr {$capturegroup_tellname==$Item}
			ChatMatch {^You've earned}
			ChatMatch {^You may complete this quest}
			ChatMatch {^A plaque on}
			ChatMatch {^You have already gained}
			ChatMatch {^You shock yourself}
			ChatMatch {^As you touch}
			ChatMatch {^A voice in your mind}
			ChatMatch {^According to the plaque}
			ChatMatch {^You search through the parts}
			ChatMatch {^You must wait}
			ChatMatch {^The stone eyes widens}
			ChatMatch {^Looking at the tusker corpse} ~~ Slain Protectorate
			ChatMatch {^You have killed} ~~ Slain Protectorate
			IntoPortal
		DO:	DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Finished using \`+$ItemName]`, `false`]}
				DoExpr {listmap[listcreate[`Item`, `ItemName`], `clearvar[$1]`]}
				SetState {LeaderCheck}

	~~ Repeatedly use the item
	IF: Always
		DO: DoAll
				DoExpr {actiontryuseitem[$Item]}
				SetState {UseLandscape}

~~ }


STATE: {HandleCheck} ~~ {

	~~ TODO: distance

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Handle `#check help`
	IF: Expr {(help)#getvar[capturegroup_checktext]}
		DO: DoAll
				DoExpr {echo[`#check buffs: check how much time is left on each characters buffs.`, $COLOR_INFO]}
				DoExpr {echo[`#check luminance: check how much luminance each character has.`, $COLOR_INFO]}
				DoExpr {echo[`#check level: check what level each character is.`, $COLOR_INFO]}
				DoExpr {echo[`#check landblock: check what landblock each character is in.`, $COLOR_INFO]}
				DoExpr {echo[`#check landcell: check what landcell each character is in.`, $COLOR_INFO]}
				DoExpr {echo[`#check settings: check the settings (Toggle Vitals, Buff, Combat, Nav, Loot) of all characters.`, $COLOR_INFO]}
				SetState {Idle}

	~~ Handle `#check buffs`
	IF: Expr {(buffs)#getvar[capturegroup_checktext]}
		DO: DoAll
				DoExpr {$total_seconds=getspellexpirationbyname[@CCCheckBuffsSpell]}
				DoExpr {$hours=floor[$total_seconds/3600]}
				DoExpr {$remaining_seconds=$total_seconds%3600}
				DoExpr {$minutes=floor[$remaining_seconds/60]}
				DoExpr {$seconds=$remaining_seconds%60}
				ChatExpr {`/t `+@CCLeader+`, Buffs: `+$hours+` hours, `+$minutes+` minutes, `+$seconds+` seconds`}
				SetState {Idle}

	~~ Handle `#check luminance`
	IF: Expr {(luminance)#getvar[capturegroup_checktext]}
		DO: DoAll
				ChatExpr {`/t `+@CCLeader+`, Luminance: `+cstrf[getcharquadprop[6], `N0`]}
				SetState {Idle}

	~~ Handle `#check level`
	IF: Expr {(level)#getvar[capturegroup_checktext]}
		DO: DoAll
				ChatExpr {`/t `+@CCLeader+`, Level: `+getcharintprop[25]}
				SetState {Idle}

	~~ Handle `#check landblock`
	IF: Expr {(landblock)#getvar[capturegroup_checktext]}
		DO: DoAll
				ChatExpr {`/t `+@CCLeader+`, Landblock: `+hexstr[getplayerlandblock[]]}
				SetState {Idle}

	~~ Handle `#check landcell`
	IF: Expr {(landcell)#getvar[capturegroup_checktext]}
		DO: DoAll
				ChatExpr {`/t `+@CCLeader+`, Landblock: `+hexstr[getplayerlandcell[]]}
				SetState {Idle}

	~~ Handle `#check settings`
	IF: Expr {(settings)#getvar[capturegroup_checktext]}
		DO: DoAll
				ChatExpr {`/t `+@CCLeader+`, Toggle Vitals: `+ifthen[@CCVitals, `On`, `Off`]+`, Buff: `+ifthen[vtgetsetting[EnableBuffing], `On`, `Off`]+`, Combat: `+ifthen[vtgetsetting[EnableCombat], `On`, `Off`]+`, Nav: `+ifthen[vtgetsetting[EnableNav], `On`, `Off`]+`, Loot: `+ifthen[vtgetsetting[EnableLooting], `On`, `Off`]}
				SetState {Idle}

	~~ Handle no match for checktext
	IF: Expr {$LEVEL_WARN>=@CCDebug}
		DO: DoAll
				DoExpr {echo[`[WARN] No matching action for #check`, $COLOR_WARN]}
				SetState {Idle}

~~ }


STATE: {AutoLoot} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Warn if there are no corpses
	IF: Expr {listcount[wobjectfindalllandscapebyobjectclass[$CORPSE]]==0}
		DO: DoAll
				DoExpr {ifthen[$LEVEL_WARN>=@CCDebug, `echo[\`[WARN] No corpses found\`, $COLOR_WARN]`, `false`]}
				SetState {Idle}

	~~ Find all corpses with a name in $AUTO_LOOT_CORPSES
	IF: Expr {listcount[wobjectfindalllandscapebyobjectclass[$CORPSE]]>0}
		DO: DoAll
				DoExpr {$foundCorpses=listfilter[wobjectfindalllandscapebyobjectclass[$CORPSE], `listcontains[dictkeys[$AUTO_LOOT_CORPSES], wobjectgetstringprop[$1, $STRING_PROP_NAME]]`]}

	~~ Warn if no corpses found with a name in $AUTO_LOOT_CORPSES
	IF: All
			Expr {listcount[wobjectfindalllandscapebyobjectclass[$CORPSE]]>0}
			Expr {listcount[$foundCorpses]==0}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, No auto loot corpses found!\`]`, `false`]}
				DoExpr {clearvar[foundCorpses]}
				SetState {Idle}

	~~ Send the first corpse found to Loot
	IF: All
			Expr {listcount[wobjectfindalllandscapebyobjectclass[$CORPSE]]>0}
			Expr {listcount[$foundCorpses]>0}
		DO: DoAll
				DoExpr {$LootCorpseItem=dictgetitem[$AUTO_LOOT_CORPSES, wobjectgetstringprop[listgetitem[$foundCorpses, 0], $STRING_PROP_NAME]]}
				DoExpr {$LootCorpseName=wobjectgetstringprop[listgetitem[$foundCorpses, 0], $STRING_PROP_NAME]}
				DoExpr {clearvar[foundCorpses]}
				SetState {Loot}

~~ }


STATE: {Loot} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	DoAll
				DoExpr {listmap[listcreate[`CorpseBlacklist`, `ItemCount`, `CorpseItemsWanted`, `Corpse`, `item`, `LootCorpseItem`, `LootCorpseName`, `allCorpses`, `foundCorpses`, `nearbyCorpses`], `clearvar[$1]`]}
				SetState {Idle}

	~~ Disable all options
	IF: Expr {testvar[OptionsSet]==false}
		DO: CallState {DisableOptions} {Loot}

	IF: Expr {testvar[CorpseBlacklist]==false}
		DO: DoExpr {$CorpseBlacklist=listcreate[]}

	~~ Drop to peace mode for looting
	IF: Always
		DO: DoAll
				DoExpr {setvar[OriginalCombatState, getcombatstate[]]}
				DoExpr {setcombatstate[peace]}

	~~ Find Potential Corpses
	IF: Always
		DO: DoAll
				DoExpr {$allCorpses=wobjectfindalllandscapebynamerx[$LootCorpseName]}
				DoExpr {$nearbyCorpses=listfilter[$allCorpses, `coordinatedistancewithz[wobjectgetphysicscoordinates[$1], getplayercoordinates[]]<=15`]}
				DoExpr {$foundCorpses=listfilter[$nearbyCorpses, `listcontains[$CorpseBlacklist, wobjectgetid[$1]]==false`]}

	~~ Out of corpses
	IF: Expr {listcount[$foundCorpses]==0}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, No corpses found with \`+$LootCorpseItem]`, `false`]}
				DoExpr {listmap[listcreate[`CorpseBlacklist`, `ItemCount`, `CorpseItemsWanted`, `Corpse`, `item`, `LootCorpseItem`, `LootCorpseName`, `allCorpses`, `foundCorpses`, `nearbyCorpses`], `clearvar[$1]`]}
				SetState {LeaderCheck}

	~~ OpenCorpse of first foundCorpse
	IF: Expr {listcount[$foundCorpses]>0}
		DO: DoAll
				DoExpr {$Corpse=listpop[$foundCorpses, 0]}
				SetState {OpenCorpse}

~~ }

STATE: {OpenCorpse} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	DoAll
				DoExpr {listmap[listcreate[`CorpseBlacklist`, `ItemCount`, `CorpseItemsWanted`, `Corpse`, `item`, `LootCorpseItem`, `LootCorpseName`, `allCorpses`, `foundCorpses`, `nearbyCorpses`], `clearvar[$1]`]}
				SetState {LeaderCheck}

	~~ Has an open corpse
	IF: Expr {getobjectinternaltype[wobjectgetopencontainer[]]==$TYPE_OBJECT}
		DO: DoAll
				~~ DoExpr {ifthen[$LEVEL_INFO>=@CCDebug, `echo[\`[INFO] Opened corpse\`, $COLOR_INFO]`, `false`]}
				SetState {LootCorpse}

	~~ Try opening the corpse
	IF: Always
		DO: DoAll
				DoExpr {$actiontryuseitem[$Corpse]}
				SetState {OpenCorpse}

	~~ FIXME: Handle corpse dissappearing
~~ }


STATE: {LootCorpse} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	DoAll
				DoExpr {listmap[listcreate[`CorpseBlacklist`, `ItemCount`, `CorpseItemsWanted`, `Corpse`, `item`, `LootCorpseItem`, `LootCorpseName`, `allCorpses`, `foundCorpses`, `nearbyCorpses`], `clearvar[$1]`]}
				SetState {LeaderCheck}

	~~ IF: Always
	~~ 	DO: DoAll
	~~ 			DoExpr {ifthen[$LEVEL_INFO>=@CCDebug, `echo[\`[INFO] Looting corpse\`, $COLOR_INFO]`, `false`]}

	~~ Disable jump confirmation since we don't need it for looting
	IF: All
			Expr {@CCJumpLoot==true}
			Expr {uboptget[`Jumper.ThinkComplete`]==true}
		DO: DoAll
				DoExpr {uboptset[`Jumper.ThinkComplete`, false]}
				DoExpr {uboptset[`Jumper.ThinkFail`, false]}
				DoExpr {setvar[jumped, false]}

	~~ Count how many of the item is in inventory
	IF: Expr {testvar[ItemCount]==false}
		DO: DoAll
				DoExpr {$ItemCount=getitemcountininventorybynamerx[$LootCorpseItem]}
				DoExpr {`$ItemCount: `+$ItemCount}

	~~ Corpse is not open
	IF: Expr {getobjectinternaltype[wobjectgetopencontainer[]]!=$TYPE_OBJECT}
		DO: DoAll
				DoExpr {ifthen[$LEVEL_INFO>=@CCDebug, `echo[\`[WARN] Corpse is not open!\`, $COLOR_WARN]`, `false`]}
				SetState {OpenCorpse}

	~~ Find all wanted items on the corpse
	IF: Expr {getobjectinternaltype[wobjectgetopencontainer[]]==$TYPE_OBJECT}
		DO: DoAll
				DoExpr {$CorpseItems=wobjectfindallbycontainer[wobjectgetopencontainer[]]}
				DoExpr {$CorpseItemsWanted=listfilter[$CorpseItems, `wobjectgetstringprop[$1, $STRING_PROP_NAME]==$LootCorpseItem`]}

	~~ Warn if unable to pickup item
	IF: Any
			ChatMatch {You have solved}
			ChatMatch {You cannot pick up more than}
			ChatMatch {You must wait}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Unable to loot \`+$LootCorpseItem]`, `false`]}
				DoExpr {ifthen[getobjectinternaltype[wobjectgetopencontainer[]]==$TYPE_OBJECT, `actiontryuseitem[wobjectgetopencontainer[]]`, `false`]}  ~~ Close the container
				DoExpr {listmap[listcreate[`jumped`, `CorpseBlacklist`, `ItemCount`, `CorpseItemsWanted`, `Corpse`, `item`, `LootCorpseItem`, `LootCorpseName`, `allCorpses`, `foundCorpses`, `nearbyCorpses`], `clearvar[$1]`]}
				DoExpr {ifthen[uboptget[`Jumper.ThinkComplete`]==false, `uboptset[\`Jumper.ThinkComplete\`, true]`, `false`]} ~~ Reset jumping confirmation if turned on
				DoExpr {ifthen[uboptget[`Jumper.ThinkFail`]==false, `uboptset[\`Jumper.ThinkFail\`, true]`, `false`]}
				SetState {CloseCorpse}

	~~ Picked up an item since inventory has increased
	IF: Expr {getitemcountininventorybynamerx[$LootCorpseItem]>$ItemCount}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Looted \`+$LootCorpseItem]`, `false`]}
				DoExpr {ifthen[getobjectinternaltype[wobjectgetopencontainer[]]==$TYPE_OBJECT, `actiontryuseitem[wobjectgetopencontainer[]]`, `false`]}  ~~ Close the container
				DoExpr {listmap[listcreate[`jumped`, `CorpseBlacklist`, `ItemCount`, `CorpseItemsWanted`, `Corpse`, `item`, `LootCorpseItem`, `LootCorpseName`, `allCorpses`, `foundCorpses`, `nearbyCorpses`], `clearvar[$1]`]}
				DoExpr {ifthen[uboptget[`Jumper.ThinkComplete`]==false, `uboptset[\`Jumper.ThinkComplete\`, true]`, `false`]} ~~ Reset jumping confirmation if turned on
				DoExpr {ifthen[uboptget[`Jumper.ThinkFail`]==false, `uboptset[\`Jumper.ThinkFail\`, true]`, `false`]}
				SetState {CloseCorpse}

	~~ Warn if no items found on the corpse
	IF: Expr {listcount[$CorpseItemsWanted]==0}
		DO: DoAll
				DoExpr {ifthen[$LEVEL_WARN>=@CCDebug, `echo[\`[WARN] Did not find the item \`+$LootCorpseItem+\` on \`+$LootCorpseName, $COLOR_WARN]`, `false`]}
				DoExpr {ifthen[getobjectinternaltype[wobjectgetopencontainer[]]==$TYPE_OBJECT, `actiontryuseitem[wobjectgetopencontainer[]]`, `false`]}  ~~ Close the container
				DoExpr {listadd[$CorpseBlacklist, wobjectgetid[$Corpse]]}
				SetState {Loot}

	~~ Pickup item from the corpse
	IF: Expr {listcount[$CorpseItemsWanted]>0}
		DO: DoAll
				DoExpr {ifthen[@CCJumpLoot&&$jumped==false, `chatbox[\`/ub jump\`]`, `false`]}  ~~ Try jumping once to break animation and loot faster
				DoExpr {setvar[jumped, true]}
				DoExpr {$item=listpop[$CorpseItemsWanted, 0]}
				DoExpr {actiontryuseitem[$item]}
				SetState {LootCorpse}

	~~ /ub mexec wobjectgetstringprop[wobjectfindallbycontainer[wobjectgetopencontainer[]]{0}, 1]
	~~ Ghost items in the inventory can be handled by getbusy or setting a timer and waiting

~~ }


STATE: {CloseCorpse} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	DoAll
				DoExpr {listmap[listcreate[`CorpseBlacklist`, `ItemCount`, `CorpseItemsWanted`, `Corpse`, `item`, `LootCorpseItem`, `LootCorpseName`, `allCorpses`, `foundCorpses`, `nearbyCorpses`], `clearvar[$1]`]}
				SetState {LeaderCheck}

	~~ Return to the original combat state
	IF: Expr {testvar[OriginalCombatState]==true&&getcombatstate[]!=$OriginalCombatState}
		DO: DoAll
				DoExpr {setcombatstate[$OriginalCombatState]}
				DoExpr {clearvar[OriginalCombatState]}

	~~ Corpse is closed; finish looting
	IF: Expr {getobjectinternaltype[wobjectgetopencontainer[]]!=$TYPE_OBJECT}
		DO: SetState {LeaderCheck}

	~~ Has an open corpse so try closing it
	IF: Expr {getobjectinternaltype[wobjectgetopencontainer[]]==$TYPE_OBJECT}
		DO: DoAll
				DoExpr {ifthen[getobjectinternaltype[wobjectgetopencontainer[]]==$TYPE_OBJECT, `actiontryuseitem[wobjectgetopencontainer[]]`, `false`]}  ~~ Close the container
				SetState {CloseCorpse}

~~ }


STATE: {UsePortal} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Disable all options
	IF: Expr {testvar[OptionsSet]==false}
		DO: CallState {DisableOptions} {UsePortal}

	~~ No portal within range but there is an NPC nearby
	IF: All
			Expr {isportaling[]==false}
			Expr {getobjectinternaltype[wobjectfindnearestbyobjectclass[$NPC]]==$TYPE_OBJECT} ~~ NPC within range
			Any
				Expr {wobjectfindnearestbyobjectclass[$PORTAL]==false} ~~ No portal detected
				Not Expr {coordinatedistancewithz[wobjectgetphysicscoordinates[wobjectfindnearestbyobjectclass[$PORTAL]], getplayercoordinates[]]<=@CCPortalThreshold} ~~ No portal within threshold
		DO: SetState {UsePortalNPC}

	~~ No portal or NPC within range
	IF: All
			Expr {isportaling[]==false}
			Any
				Expr {wobjectfindnearestbyobjectclass[$PORTAL]==false} ~~ no portal detected
				Not Expr {coordinatedistancewithz[wobjectgetphysicscoordinates[wobjectfindnearestbyobjectclass[$PORTAL]], getplayercoordinates[]]<=@CCPortalThreshold} ~~ no portal within threshold
			Any
				Expr {wobjectfindnearestbyobjectclass[$NPC]==false} ~~ no NPC detected
				Not Expr {coordinatedistancewithz[wobjectgetphysicscoordinates[wobjectfindnearestbyobjectclass[$NPC]], getplayercoordinates[]]<=@CCPortalThreshold} ~~ no NPC within threshold
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, No portal within range!\`]`, `false`]}
				SetState {LeaderCheck}

	~~ Warn if you can't interact with that portal.
	IF: All
			Expr {isportaling[]==false}
			Any
				ChatMatch {You must complete a quest to interact with that portal.}
				ChatMatch {You completed the quest this portal requires too long ago!}
				ChatMatch {You must be a member of the}
				ChatMatch {Nothing happens}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Unable to use portal!\`]`, `false`]}
				SetState {LeaderCheck}

	~~ Use the Portal
	IF:	Expr {isportaling[]==false}
		DO:	DoAll
				DoExpr {actiontryuseitem[wobjectfindnearestbyobjectclass[$PORTAL]]}
				SetState {UsePortal}

	~~ Finished using portal; reset options to what they originally were
	IF:	Expr {isportaling[]==true}
		DO:	DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Finished using portal\`]`, `false`]}
				SetState {LeaderCheck}

~~ }


STATE: {UsePortalNPC} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ The NPC does not have data, we need to query for it
	IF: Expr {wobjecthasdata[wobjectfindnearestbyobjectclass[$NPC]]==false}
		DO: DoAll
				DoExpr {wobjectrequestdata[wobjectfindnearestbyobjectclass[$NPC]]}
				SetState {UsePortalNPC}

	~~ No NPC in range with `portal` in description
	IF: All
			Expr {wobjecthasdata[wobjectfindnearestbyobjectclass[$NPC]]==true}
			Not Expr {istrue[wobjectgetstringprop[wobjectfindnearestbyobjectclass[$NPC], $STRING_PROP_DESCRIPTION]#portal]}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, No portal within range!\`]`, `false`]}
				SetState {LeaderCheck}

	~~ Use the NPC Portal
	IF:	All
			Expr {isportaling[]==false}
			Expr {wobjecthasdata[wobjectfindnearestbyobjectclass[$NPC]]==true}
			Expr {istrue[wobjectgetstringprop[wobjectfindnearestbyobjectclass[$NPC], $STRING_PROP_DESCRIPTION]#portal]}
		DO:	DoAll
				DoExpr {actiontryuseitem[wobjectfindnearestbyobjectclass[$NPC]]}
				SetState {UsePortalNPC}

	~~ Finished using portal; go to LeaderCheck
	IF:	Expr {isportaling[]==true}
		DO:	DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Finished using portal\`]`, `false`]}
				SetState {LeaderCheck}

~~ }


STATE: {UseVRPortal} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Disable all options
	IF: Expr {testvar[OptionsSet]==false}
		DO: CallState {DisableOptions} {UseVRPortal}

	~~ Use the VR portal
	IF:	Expr {isportaling[]==false}
		DO:	DoAll
				DoExpr {actiontryuseitem[wobjectfindnearestbynameandobjectclass[$NPC, `Viridian Portal`]]}
				SetState {UseVRPortal}

	~~ Finished using portal; go to LeaderCheck
	IF:	Expr {isportaling[]==true}
		DO:	DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Finished using VR portal\`]`, `false`]}
				SetState {LeaderCheck}

~~ }


STATE: {LeaderCheck} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Warn if commands are issued
	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#(?<command>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, I cannot listen to commands! I am currently in the state \`+vtgetmetastate[]]`, `false`]}

	~~ Disable all options if other states haven't
	IF: Expr {testvar[OptionsSet]==false}
		DO: CallState {DisableOptions} {LeaderCheck}

	~~ If leader go straight to EnableOptions
	IF: Expr {@CCLeader==$CHARACTER_NAME}
		DO: CallState {EnableOptions} {Idle}

	~~ If not following go straight to EnableOptions
	IF: Expr {@CCStay==true}
		DO: CallState {EnableOptions} {Idle}

	~~ If following re-enable follow when leader is nearby
	IF: All
			Expr {@CCStay==false}
			Expr {@CCLeader!=$CHARACTER_NAME}
			Expr {getobjectinternaltype[wobjectfindnearestbynameandobjectclass[$PLAYER, @CCLeader]]==$TYPE_OBJECT}  ~~ CCLeader WObject exists
			Expr {coordinatedistancewithz[wobjectgetphysicscoordinates[wobjectfindnearestbynameandobjectclass[$PLAYER, @CCLeader]], getplayercoordinates[]]<=@CCLeaderCheckDistance}  ~~ CCLeader is nearby
		DO: DoAll
				SetOpt {NavPriorityBoost} {true}
				ChatExpr {`/ub follow `+@CCLeader}

	~~ When leader is nearby leave check
	IF: All
			Expr {getobjectinternaltype[wobjectfindnearestbynameandobjectclass[$PLAYER, @CCLeader]]==$TYPE_OBJECT}  ~~ CCLeader WObject exists
			Expr {coordinatedistancewithz[wobjectgetphysicscoordinates[wobjectfindnearestbynameandobjectclass[$PLAYER, @CCLeader]], getplayercoordinates[]]<=@CCLeaderCheckDistance}  ~~ CCLeader is nearby
		DO: CallState {EnableOptions} {Idle}

	~~ Warn if in the check too long
	IF:	SecsInStateGE 15
		DO: DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Waiting for nearby leader for 15 seconds!\`]`, `false`]}

	~~ Disable waiting if longer than the timeout
	IF: SecsInStateGE 30
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Timeout reached waiting for leader! Staying but listening for commands.\`]`, `false`]}
				EmbedNav Empty {[None]}
				DoExpr {@CCStay=true}
				CallState {EnableOptions} {Idle}

~~ }


STATE: {HandleFellow} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	IF: Expr {(help)#getvar[capturegroup_fellowtext]}
		DO: DoAll
				DoExpr {echo[`#fellow add: Add characters by name`, $COLOR_INFO]}
				DoExpr {echo[`#fellow close: Close the fellow`, $COLOR_INFO]}
				DoExpr {echo[`#fellow create: Create a fellow and add all characters in @CCCharacterList`, $COLOR_INFO]}
				DoExpr {echo[`#fellow disband: Disband the fellow`, $COLOR_INFO]}
				DoExpr {echo[`#fellow leader: Make the issuer of the command leader`, $COLOR_INFO]}
				DoExpr {echo[`#fellow nearby: Add all characters close to the issuer of the command`, $COLOR_INFO]}
				DoExpr {echo[`#fellow open: Open the fellow`, $COLOR_INFO]}
				DoExpr {echo[`#fellow quit: All characters quit the fellow`, $COLOR_INFO]}
				SetState {Idle}

	~~ Handle `#fellow close` for the leader
	IF: All
			Expr {(close)#getvar[capturegroup_fellowtext]}
			Expr {getfellowshipisleader[]==true}
		DO: DoAll
				ChatExpr {`/ub fellow close`}
				SetState {Idle}

	~~ Handle `#fellow close` for followers
	IF: All
			Expr {(close)#getvar[capturegroup_fellowtext]}
			Expr {getfellowshipisleader[]==false}
		DO:	SetState {Idle}

	~~ Handle `#fellow create` for the character who issued the command
	IF: All
			Expr {(create)#getvar[capturegroup_fellowtext]}
			Expr {$capturegroup_name==false}
		DO:	SetState {FellowCreate}

	~~ Handle `#fellow create` for followers
	IF: All
			Expr {(create)#getvar[capturegroup_fellowtext]}
			Expr {$capturegroup_name!=false}
		DO:	SetState {Idle}

	~~ Handle `#fellow disband` for leader
	IF: All
			Expr {(disband)#getvar[capturegroup_fellowtext]}
			Expr {getfellowshipisleader[]==true}
		DO:	DoAll
				ChatExpr {`/ub fellow disband`}
				SetState {Idle}

	~~ Handle `#fellow disband` for followers
	IF: All
			Expr {(disband)#getvar[capturegroup_fellowtext]}
			Expr {getfellowshipisleader[]==false}
		DO:	SetState {Idle}

	~~ Handle `#fellow leader` for leader
	IF: All
			Expr {(leader)#getvar[capturegroup_fellowtext]}
			Expr {getfellowshipisleader[]==true}
		DO:	DoAll
				ChatExpr {`/ub fellow leader `+$capturegroup_name}
				SetState {Idle}

	~~ Handle `#fellow leader` for followers
	IF: All
			Expr {(leader)#getvar[capturegroup_fellowtext]}
			Expr {getfellowshipisleader[]==false}
		DO:	SetState {Idle}

	~~ Handle `#fellow nearby` for character who issued the command
	IF: All
			Expr {(nearby)#getvar[capturegroup_fellowtext]}
			Expr {$capturegroup_name==false}
		DO:	SetState {FellowNearby}

	~~ Handle `#fellow nearby` for followers
	IF: All
			Expr {(nearby)#getvar[capturegroup_fellowtext]}
			Expr {$capturegroup_name!=false}
		DO:	SetState {Idle}

	~~ Handle `#fellow open` for the leader
	IF: All
			Expr {(open)#getvar[capturegroup_fellowtext]}
			Expr {getfellowshipisleader[]==true}
		DO: DoAll
				ChatExpr {`/ub fellow open`}
				SetState {Idle}

	~~ Handle `#fellow open` for followers
	IF: All
			Expr {(open)#getvar[capturegroup_fellowtext]}
			Expr {getfellowshipisleader[]==false}
		DO:	SetState {Idle}

	~~ Handle `#fellow quit`
	IF: Expr {(quit)#getvar[capturegroup_fellowtext]}
		DO:	DoAll
				ChatExpr {`/ub fellow quit`}
				SetState {Idle}

	~~ Handle no match for actiontext
	IF: Expr {$LEVEL_WARN>=@CCDebug}
		DO: DoAll
				DoExpr {echo[`[WARN] No matching parameter for #fellow`, $COLOR_WARN]}
				SetState {Idle}

~~ }


STATE: {FellowCreate} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Create the fellow
	IF:	Always
		DO:	ChatExpr {`/ub fellow create `+@CCFellowname}

	~~ If fellow is created move to FellowInvite
	IF:	Expr {getfellowshipstatus[]==1}
		DO:	SetState {FellowInvite}

	~~ If fellow isn't created try again
	IF:	SecsInStateGE 1
		DO:	SetState {FellowCreate}

~~ }


STATE: {FellowInvite} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Create blacklist
	IF: Expr {testvar[FellowBlacklist]==false}
		DO: DoExpr {$FellowBlacklist=listcreate[]}

	~~ Find all nearby players who are in @CCCharacterList
	IF: Always
		DO: DoAll
				DoExpr {$AllNearbyPlayers=listmap[wobjectfindallbyobjectclass[$PLAYER],`wobjectgetstringprop[$1,1]`]}
				DoExpr {$AllNearbyCharacterList=listfilter[$AllNearbyPlayers, `listcontains[@CCCharacterList, $1]`]}
				DoExpr {$AllNearbyNotInFellow=listfilter[$AllNearbyCharacterList, `listcontains[getfellownames[], $1]==false`]}
				DoExpr {$AllNearbyNotInFellowNotBlacklisted=listfilter[$AllNearbyNotInFellow, `listcontains[$FellowBlacklist, $1]==false`]}

	~~ Clear variables and return to idle if there are no more players to add
	IF: Expr {listcount[$AllNearbyNotInFellowNotBlacklisted]==0}
		DO: DoAll
				DoExpr {listmap[listcreate[`AllNearbyPlayers`, `AllNearbyCharacterList`, `AllNearbyNotInFellow`, `AllNearbyNotInFellowNotBlacklisted`, `FellowBlacklist`, `name`], `clearvar[$1]`]}
				SetState {Idle}

	~~ Recruit a nearby player in $CCCharacterlist
	IF: Always
		DO: DoAll
				DoExpr {$name=listpop[$AllNearbyNotInFellowNotBlacklisted, 0]}
				ChatExpr {`/ub fellow recruit `+$name}
				SetState {FellowInvite}

	~~ Blacklist the character if already in a fellow
	IF: Any
			ChatMatch {is already a member of a Fellowship.$}
			ChatMatch {is not accepting fellowship requests.$}
		DO: DoAll
				DoExpr {listadd[$FellowBlacklist, $name]}
				SetState {FellowInvite}

~~ }


STATE: {FellowNearby} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Abort if not in a fellow
	IF: Expr {getfellowshipstatus[]==false}
		DO: DoAll
				DoExpr {ifthen[$LEVEL_WARN>=@CCDebug, `echo[\`[WARN] Aborting, not in a fellow\`, $COLOR_WARN]`, `false`]}
				SetState {Idle}

	~~ Create blacklist
	IF: Expr {testvar[FellowBlacklist]==false}
		DO: DoExpr {$FellowBlacklist=listcreate[]}

	~~ Find all nearby characters
	IF: Always
		DO: DoAll
				DoExpr {$AllNearbyPlayers=listmap[wobjectfindallbyobjectclass[$PLAYER], `wobjectgetstringprop[$1, 1]`]}
				DoExpr {$AllNearbyExceptSelf=listfilter[$AllNearbyPlayers, `$1!=$CHARACTER_NAME`]}
				DoExpr {$AllNearbyPlayersWithinRange=listfilter[$AllNearbyExceptSelf, `coordinatedistancewithz[wobjectgetphysicscoordinates[wobjectfindnearestbynameandobjectclass[$PLAYER, $1]], getplayercoordinates[]]<@CCFellowNearbyRecruitDistance`]}
				DoExpr {$AllNearbyNotInFellow=listfilter[$AllNearbyPlayersWithinRange, `listcontains[getfellownames[], $1]==false`]}
				DoExpr {$AllNearbyNotInFellowNotBlacklisted=listfilter[$AllNearbyNotInFellow, `listcontains[$FellowBlacklist, $1]==false`]}

			~~ Expr {coordinatedistancewithz[wobjectgetphysicscoordinates[wobjectfindnearestbynameandobjectclass[$NPC, `Viridian Portal`]],getplayercoordinates[]]<$CLOSE_BLUE}

	~~ Clear variables and return to idle if there are no more characters to add
	IF: Any
			Expr {listcount[$AllNearbyNotInFellowNotBlacklisted]==0}
			Expr {getfellowshipcount[]>=@CCMaxFellowshipSize}
		DO: DoAll
				DoExpr {listmap[listcreate[`AllNearbyPlayers`, `AllNearbyExceptSelf`, `AllNearbyPlayersWithinRange`, `AllNearbyNotInFellow`, `AllNearbyNotInFellowNotBlacklisted`, `FellowBlacklist`, `name`], `clearvar[$1]`]}
				SetState {Idle}

	~~ Recruit a nearby character
	IF: Always
		DO: DoAll
				DoExpr {$name=listpop[$AllNearbyNotInFellowNotBlacklisted, 0]}
				ChatExpr {`/ub fellow recruit `+$name}
				SetState {FellowNearby}

	~~ Blacklist the character if already in a fellow
	IF: Any
			ChatMatch {is already a member of a Fellowship.$}
			ChatMatch {is not accepting fellowship requests.$}
		DO: DoAll
				DoExpr {listadd[$FellowBlacklist, $name]}
				SetState {FellowNearby}

~~}


STATE: {FellowAdd} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	IF: Always
		DO: DoExpr {$namerx=$capturegroup_namerx}

	~~ Abort if not in a fellow
	IF: Expr {getfellowshipstatus[]==false}
		DO: DoAll
				DoExpr {ifthen[$LEVEL_WARN>=@CCDebug, `echo[\`[WARN] Aborting, not in a fellow\`, $COLOR_WARN]`, `false`]}
				SetState {Idle}

	~~ Warn if no players are found
	IF: Expr {listcount[listfilter[wobjectfindallbynamerx[$namerx], `wobjectgetobjectclass[$1]==$PLAYER`]]==0}
		DO: DoAll
				DoExpr {ifthen[$LEVEL_WARN>=@CCDebug, `echo[\`[WARN] No players found!\`, $COLOR_WARN]`, `false`]}
				SetState {Idle}

	~~ Create blacklist
	IF: Expr {testvar[FellowBlacklist]==false}
		DO: DoExpr {$FellowBlacklist=listcreate[]}

	~~ Find all characters with $namerx
	IF: Always
		DO: DoAll
				DoExpr {$AllCharacters=listfilter[wobjectfindallbynamerx[$namerx], `wobjectgetobjectclass[$1]==$PLAYER`]}
				DoExpr {$AllCharacterNames=listmap[$AllCharacters, `wobjectgetstringprop[$1, 1]`]}
				DoExpr {$AllCharactersNotInFellow=listfilter[$AllCharacterNames, `listcontains[getfellownames[], $1]==false`]}
				DoExpr {$AllCharactersNotInFellowNotBlacklisted=listfilter[$AllCharactersNotInFellow, `listcontains[$FellowBlacklist, $1]==false`]}

	~~ Clear variables and return to idle if there are no more characters to add
	IF: Any
			Expr {listcount[$AllCharactersNotInFellowNotBlacklisted]==0}
			Expr {getfellowshipcount[]>=@CCMaxFellowshipSize}
		DO: DoAll
				DoExpr {listmap[listcreate[`AllCharacters`, `AllCharacterNames`, `AllCharactersNotInFellow`, `AllCharactersNotInFellowNotBlacklisted`, `FellowBlacklist`, `name`, `namerx`], `clearvar[$1]`]}
				SetState {Idle}

	~~ Recruit a character
	IF: Always
		DO: DoAll
				DoExpr {$name=listpop[$AllCharactersNotInFellowNotBlacklisted, 0]}
				DoExpr {ifthen[$LEVEL_DEBUG>=@CCDebug, `echo[\`[INFO] recruiting \`+$name, $COLOR_INFO]`, `false`]}
				ChatExpr {`/ub fellow recruit `+$name}
				SetState {FellowAdd}

	~~ Blacklist the character if already in a fellow
	IF: Any
			ChatMatch {is already a member of a Fellowship.$}
			ChatMatch {is not accepting fellowship requests.$}
		DO: DoAll
				DoExpr {listadd[$FellowBlacklist, $name]}
				SetState {FellowAdd}

~~ }


STATE: {HandleRecall} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Return to Idle if the spell isn't known
	IF: Not Expr {getisspellknown[$CCRecallSpell]}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, I do not know this recall spell\`]`, `false`]}
				SetState {Idle}

	~~ Disable all options
	IF: Expr {testvar[OptionsSet]==false}
		DO: CallState {DisableOptions} {HandleRecall}

	~~ Close recalls view
	IF: Expr {uiviewvisible[Recalls]}
		DO: DoAll
				DoExpr {uisetlabel[uigetcontrol[Main, ShowNavto], `Navto >>`]}
				DestroyView {Recalls}

	~~ Cast the recall spell
	IF: Expr {isportaling[]==false}
		DO: DoAll
				DoExpr {actiontrycastbyid[$CCRecallSpell]}
				SetState {HandleRecall}

	~~ Finished recalling; go to LeaderCheck
	IF: Expr {isportaling[]==true}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Finished recalling\`]`, `false`]}
				SetState {LeaderCheck}

~~}

STATE: {HandleSummonPortal} ~~ {
	IF:	ChatMatch {![Rr]eset}
		DO:	CallState {CleanUpHandleSummonPortal} {Idle}

	~~ Return to Idle if the spell isn't known
	IF: Not Expr {getisspellknown[$CCRecallSpell]}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, I do not know this spell\`]`, `false`]}
				SetState {Idle}

	~~ Disable all options
	IF: Expr {testvar[OptionsSet]==false}
		DO: DoAll
				CallState {DisableOptions} {HandleSummonPortal}

	~~ Close recalls view
	IF: Expr {uiviewvisible[Recalls]}
		DO: DoAll
				DoExpr {uisetlabel[uigetcontrol[Main, ShowNavto], `Navto >>`]}
				DestroyView {Recalls}
	
	IF: Expr {getvar[capturegroup_name]==false]}
		DO: DoAll
				DoExpr {setvar[castingCharacterHeading, getheading[wobjectgetplayer[]]]}

	IF: Expr {getvar[capturegroup_name]!=false]}
		DO: DoAll
				SetState {ListenForSummonPortal}

	~~ Cast the recall spell
	IF: All
			Expr {getvar[capturegroup_name]==false]} ~~ Only the character who issued the command can summon a portal. Didn't capture a name because it was 'say' or 'think'
		DO: DoAll			
				DoExpr {setvar[maxCastAttempts, 3]} ~~ Set the maximum number of cast attempts
				DoExpr {setvar[currentAttemptCount, 0]} ~~ Set a variable to indicate if the spell was cast successfully
				SetState {TrycastSummonPortal}
~~ }

STATE: {TrycastSummonPortal} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	CallState {CleanUpHandleSummonPortal} {Idle}

	IF: Expr {getvar[currentAttemptCount]>=getvar[maxCastAttempts]} ~~ Maximum number of cast attempts reached
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Failed to cast the spell after `+getvar[currentAttemptCount]+` attempts\`]`, `false`]}
				CallState {CleanUpHandleSummonPortal} {LeaderCheck}

	~~ Cast the recall spell
	IF: Expr {$wasCastSuccessfull==false}
		DO: DoAll
				DoExpr {setvar[currentAttemptCount, getvar[currentAttemptCount]+1]}
				DoExpr {$wasCastSuccessfull=actiontrycastbyid[$CCRecallSpell]}
				SetState {TrycastSummonPortal}

	~~ Cast the recall spell
	IF: Expr {$wasCastSuccessfull==true}
		DO: DoAll
				SetState {LocateSummonedPortal}

~~ }

STATE: {LocateSummonedPortal} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	CallState {CleanUpHandleSummonPortal} {Idle}

	IF: All
			SecsInStateGE 3
			Expr {getvar[checkedForGateways]==false} ~~ gatewayList is not set yet
		DO: DoAll
				DoExpr {setvar[checkedForGateways, true]} ~~ Set a variable to indicate that we checked for gateways
				DoExpr {setvar[gatewayList, wobjectfindallbynamerx[Gateway]]}
				SetState {LocateSummonedPortal}

	IF: All			
			Expr {getvar[checkedForGateways]==true}
			Expr {listcount[getvar[gatewayList]]>0}
			Expr {setvar[currentGateway,listpop[getvar[gatewayList]]]&&getheading[getvar[currentGateway]]==getvar[castingCharacterHeading]&&setvar[foundGatewayId, wobjectgetid[$currentGateway]]} ~~ Loop through surrounding gateways and find the one that matches the heading of the character who casted the spell
		DO: DoAll
				ChatExpr {`/`+@CCChatCommand+` #portal found ` + getvar[foundGatewayId]}
				SetState {ListenForSummonPortal}

	IF: All
			Expr {getvar[checkedForGateways]==true}
			Expr {listcount[getvar[gatewayList]]==0} ~~ No gateways found
			Expr {getvar[foundGatewayId]==false} ~~ Gateway not found
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, No gateway found!\`]`, `false`]}
				CallState {CleanUpHandleSummonPortal} {LeaderCheck}
~~ }

STATE: {ListenForSummonPortal} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	CallState {CleanUpHandleSummonPortal} {Idle}

	IF:	All
			ChatCapture {(^(\[[A-z]+?\] |)You|.*\<Tell:IIDString:.+:(?<name>[^\<]*)\>.+\<\\Tell\>) (?<saythink>.*), \"#portal found (?<portalid>.*)\"$} {}
			Any
				Expr {$capturegroup_saythink==`say`}
				Expr {$capturegroup_saythink==`think`}
				Expr {listcontains[@CCCharacterList, $capturegroup_name]}
		DO: SetState {UseSummonedPortal}

~~ }

STATE: {UseSummonedPortal} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	CallState {CleanUpHandleSummonPortal} {Idle}

	~~ Disable all options
	IF: Expr {testvar[OptionsSet]==false}
		DO: CallState {DisableOptions} {UseSummonedPortal}

	~~ Close recalls view
	IF: Expr {uiviewvisible[Recalls]}
		DO: DoAll
				DoExpr {uisetlabel[uigetcontrol[Main, ShowNavto], `Navto >>`]}
				DestroyView {Recalls}

	~~ Use the Summoned Portal
	IF: All
			Expr {isportaling[]==false}
			Expr {getvar[capturegroup_portalid]!=false} ~~ Gateway exists
		DO: DoAll
				DoExpr {actiontryuseitem[wobjectfindbyid[cnumber[getvar[capturegroup_portalid]]]]}
				SetState {UseSummonedPortal}

	~~ Finished using the Summoned Portal; go to LeaderCheck
	IF: Expr {isportaling[]==true}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+$capturegroup_name+\`, Finished using Summoned Portal\`]`, `false`]}
				CallState {CleanUpHandleSummonPortal} {LeaderCheck}

~~ }

STATE: {CleanUpHandleSummonPortal} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Clear all variables
	IF: Always
		DO: DoAll
				DoExpr {listmap[listcreate[`castingCharacterHeading`,`foundGatewayId`,`checkedForGateways`,`gatewayList`,`currentGateway`,`maxCastAttempts`,`currentAttemptCount`,`wasCastSuccessfull`], `clearvar[$1]`]}
				Return

~~ }

STATE: {HandleCount} ~~ {
	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Display help for #count
	IF: Expr {(help)#getvar[capturegroup_counttext]}
		DO: DoAll
				DoExpr {echo[`#count <item name>: All characters report the number of the item they have.`, $COLOR_INFO]}
				DoExpr {listmap[listcreate[`capturegroup_counttext`, `capturegroup_name`, `capturegroup_saythink`], `clearvar[$1]`]}
				SetState {Idle}

	~~ Count the number of item
	IF: Always
		DO: DoAll
				DoExpr {$count=getitemcountininventorybynamerx[$capturegroup_counttext]}
				ChatExpr {`/t `+@CCLeader+`, `+$capturegroup_counttext+`: `+$count}
				DoExpr {listmap[listcreate[`capturegroup_counttext`, `capturegroup_name`, `capturegroup_saythink`, `count`], `clearvar[$1]`]}
				SetState {Idle}

~~ }


STATE: {HandleTimers} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Display help for #count
	IF: Expr {(help)#getvar[capturegroup_timertext]}
		DO: DoAll
				DoExpr {echo[`#timer <amount> [message]: Start a timer for a specific amount of time. With an optional message that will be displayed when the timer ends.`, $COLOR_INFO]}
				DoExpr {listmap[listcreate[`capturegroup_timertext`, `capturegroup_name`, `capturegroup_saythink`], `clearvar[$1]`]}
				SetState {Idle}

	IF: Always
		DO: DoAll
				DoExpr {$CCTimerAmount=cnumber[$capturegroup_timertext]*60}
				DoExpr {$CCTimerMsg=$capturegroup_timermsg}
				DoExpr {setvar[CCTimer, stopwatchstart[stopwatchcreate[]]]}

	~~ Show Timer view
	IF: Not Expr {uiviewvisible[Timer]}
		DO: DoAll
				CreateView {Timer} {:CheCommand-Timer.xml}
				SetState {Idle}

~~ }


STATE: {UseNPC} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Disable all options
	IF: Expr {testvar[OptionsSet]==false}
		DO: CallState {DisableOptions} {UseNPC}

	~~ If set equip item to talk to npc
	IF: All
			Expr {@CCEquipOnTurnin!=false}
			Expr {wobjectfindnearestbyobjectclass[31]!=@CCEquipOnTurnin}
			Expr {testvar[equipped]==false}
		DO: DoAll
				DoExpr {actiontryuseitem[@CCEquipOnTurnin]}
				DoExpr {$equipped=true}

	~~ Warn if no NPC nearby
	IF: Any
			Expr {wobjectfindnearestbyobjectclass[$NPC]==false}
			Expr {coordinatedistancewithz[wobjectgetphysicscoordinates[wobjectfindnearestbyobjectclass[$NPC]], getplayercoordinates[]]>=@CCNPCThreshold} ~~ no NPC within threshold
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, No NPC within range!\`]`, `false`]}
				SetState {LeaderCheck}

	~~ Stop using NPC if you receieve a response
	IF:	Any
			All
				ChatCapture {.*} {0}  ~~ Directbroadcast of any kind
				Expr {$capturegroup_color==0}
			All
				ChatCapture {^(?<tellname>.*?) tells you, \"(?<npctext>.*)\"$} {}
				Expr {$capturegroup_tellname==$name}
			All
				ChatCapture {^(?<tellname>.*?) gives you (?<npctext>.*)$} {}
				Expr {$capturegroup_tellname==$name}
			All
				ChatCapture {^(?<tellname>.*?) cast (?<npctext>.*)$} {}
				Expr {$capturegroup_tellname==$name}
			ChatMatch {^You've earned}
			ChatMatch {^You may complete this quest}
			ChatMatch {^A plaque on}
			ChatMatch {^You have already gained}
			ChatMatch {^You shock yourself}
			ChatMatch {^As you touch}
			ChatMatch {^A voice in your mind}
			ChatMatch {^According to the plaque}
			ChatMatch {^You search through the parts}
			ChatMatch {^You must wait}
			ChatMatch {^The stone eyes widens}
			ChatMatch {^Looking at the tusker corpse} ~~ Slain Protectorate
			ChatMatch {^You have killed} ~~ Slain Protectorate
			IntoPortal
		DO:	DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Talked to \`+$name]`, `false`]}
				DoExpr {clearvar[equipped]}
				SetState {LeaderCheck}

	~~ Use Brellegia's Marker if it's closer than an npc. Brellegia's Marker is an object class Foci instead of NPC
	IF: All
			Expr {getobjectinternaltype[wobjectfindnearestbyobjectclass[$FOCI]]==$TYPE_OBJECT}
			Expr {coordinatedistancewithz[wobjectgetphysicscoordinates[wobjectfindnearestbyobjectclass[$FOCI]], getplayercoordinates[]]<coordinatedistancewithz[wobjectgetphysicscoordinates[wobjectfindnearestbyobjectclass[$NPC]], getplayercoordinates[]]}
			Expr {wobjectgetstringprop[wobjectfindnearestbyobjectclass[$FOCI], $STRING_PROP_NAME]==`Brellegia's Marker`}
		DO: DoAll
				DoExpr {actiontryuseitem[wobjectfindnearestbyobjectclass[$FOCI]]}
				DoExpr {$name=wobjectgetstringprop[wobjectfindnearestbyobjectclass[$FOCI], $STRING_PROP_NAME]}
				SetState {UseNPC}

	~~ Use NPC if it's closer than Brellegia's Marker
	IF:	Expr {getobjectinternaltype[wobjectfindnearestbyobjectclass[$FOCI]]==$TYPE_OBJECT&&coordinatedistancewithz[wobjectgetphysicscoordinates[wobjectfindnearestbyobjectclass[$NPC]], getplayercoordinates[]]<coordinatedistancewithz[wobjectgetphysicscoordinates[wobjectfindnearestbyobjectclass[$FOCI]], getplayercoordinates[]]}
		DO: DoAll
				DoExpr {actiontryuseitem[wobjectfindnearestbyobjectclass[$NPC]]}
				DoExpr {$name=wobjectgetstringprop[wobjectfindnearestbyobjectclass[$NPC], $STRING_PROP_NAME]}
				SetState {UseNPC}

	~~ Use NPC if Brellegia's Marker is not nearby
	IF: Not Expr {getobjectinternaltype[wobjectfindnearestbyobjectclass[$FOCI]]==$TYPE_OBJECT}
		DO: DoAll
				DoExpr {actiontryuseitem[wobjectfindnearestbyobjectclass[$NPC]]}
				DoExpr {$name=wobjectgetstringprop[wobjectfindnearestbyobjectclass[$NPC], $STRING_PROP_NAME]}
				SetState {UseNPC}

~~ }


STATE: {UseVendor} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	SetState {Idle}

	~~ Disable all options
	IF: Expr {testvar[OptionsSet]==false}
		DO: CallState {DisableOptions} {UseVendor}

	~~ Autovendor finished
	IF:	ChatMatch {^You think, "AutoVendor finished}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Finished vending with \`+$name]`, `false`]}
				DoExpr {actiontryuseitem[wobjectfindnearestbyobjectclass[$VENDOR]]} ~~ Close the vendor window
				DoExpr {clearvar[open]}
				SetState {LeaderCheck}

	~~ Use Vendor
	IF: VendorClosed
		DO: DoAll
				DoExpr {actiontryuseitem[wobjectfindnearestbyobjectclass[$VENDOR]]}
				DoExpr {$name=wobjectgetstringprop[wobjectfindnearestbyobjectclass[$VENDOR], $STRING_PROP_NAME]}
				SetState {UseVendor}

~~ }


STATE: {ReadContracts} ~~ {

	IF:	ChatMatch {![Rr]eset}
		DO:	DoAll
				DoExpr {$CCReset=true}
				SetState {Finished}

	~~ If Remaining contracts try using them
	IF: Expr {getitemcountininventorybynamerx[`(Hunting\: Lost City of Neftet)|(Contract for)`]>0}
		DO: DoAll
				DoExpr {actiontryuseitem[wobjectfindininventorybynamerx[`(Hunting\: Lost City of Neftet)|(Contract for)`]]}
				SetState {ReadContracts}

	~~ No contracts left return to Idle
	IF: Expr {getitemcountininventorybynamerx[`(Hunting\: Lost City of Neftet)|(Contract for)`]==0}
		DO: DoAll
				DoExpr {ifthen[@CCConfirm==true, `chatbox[\`/t \`+@CCLeader+\`, Finished reading contracts\`]`, `false`]}
				SetState {Idle}

~~ }


STATE: {Brill} ~~ {

	IF: Expr {getcombatstate[]!=`Magic`}
		DO: DoAll
				DoExpr {setcombatstate[`Magic`]}
				SetState {Brill}

	IF: Expr {testvar[capturegroup_brillname]==false}
		DO: DoAll
				ChatExpr {`/ub use Focusing Stone on `+wobjectgetname[wobjectgetselection[]]}
				SetState {Idle}

	IF: Expr {testvar[capturegroup_brillname]==true}
		DO: DoAll
				ChatExpr {`/ub use Focusing Stone on `+$capturegroup_brillname}
				DoExpr {clearvar[capturegroup_blessingname]}
				SetState {Idle}

~~ }


STATE: {Blessing} ~~ {

	IF: Expr {getcombatstate[]!=`Magic`}
		DO: DoAll
				DoExpr {setcombatstate[`Magic`]}
				SetState {Blessing}

	IF: Expr {testvar[capturegroup_blessingname]==false}
		DO: DoAll
				ChatExpr {`/ub use Royal Bouquet on `+wobjectgetname[wobjectgetselection[]]}
				SetState {Idle}

	IF: Expr {testvar[capturegroup_blessingname]==true}
		DO: DoAll
				ChatExpr {`/ub use Royal Bouquet on `+$capturegroup_blessingname}
				DoExpr {clearvar[capturegroup_blessingname]}
				SetState {Idle}

~~ }


STATE: {DisableOptions} ~~ {

	~~ Store original options so we can reset them
	IF: Always
		DO: DoAll
				DoExpr {setvar[OriginalEnableNav, vtgetsetting[EnableNav]]}
				DoExpr {setvar[OriginalEnableCombat, vtgetsetting[EnableCombat]]}
				DoExpr {setvar[OriginalEnableBuffing, vtgetsetting[EnableBuffing]]}
				DoExpr {setvar[OriginalEnableLooting, vtgetsetting[EnableLooting]]}
				DoExpr {setvar[OptionsSet, true]}

	~~ Disable all options
	IF:	Always
		DO:	DoAll
				SetOpt {EnableNav} {False}
				SetOpt {EnableCombat} {False}
				SetOpt {EnableBuffing} {False}
				SetOpt {EnableLooting} {False}

	~~ Return
	IF: Always
		DO: Return

~~ }


STATE: {EnableOptions} ~~ {

	~~ Enable options
	IF:	Always
		DO:	DoAll
				SetOpt {EnableNav} {$OriginalEnableNav}
				SetOpt {EnableCombat} {$OriginalEnableCombat}
				SetOpt {EnableBuffing} {$OriginalEnableBuffing}
				SetOpt {EnableLooting} {$OriginalEnableLooting}

	~~ Clear all vars
	IF: Always
		DO: DoAll
				DoExpr {clearvar[OriginalEnableNav]}
				DoExpr {clearvar[OriginalEnableCombat]}
				DoExpr {clearvar[OriginalEnableBuffing]}
				DoExpr {clearvar[OriginalEnableLooting]}
				DoExpr {clearvar[OptionsSet]}

	~~ Return
	IF: Always
		DO: Return

~~ }


STATE: {ShowJump} ~~ {

	~~ Show Jump view
	IF: Not Expr {uiviewvisible[Jump]}
		DO: DoAll
				CreateView {Jump} {:CheCommand-Jump.xml}
				DoExpr {uisetlabel[uigetcontrol[Main, ShowJump], `Jump <<`]}
				DoExpr {@CCViewsJump=true}
				SetState {Idle}

	~~ Close Jump view
	IF: Expr {uiviewvisible[Jump]}
		DO: DoAll
				DestroyView {Jump}
				DoExpr {uisetlabel[uigetcontrol[Main, ShowJump], `Jump >>`]}
				DoExpr {@CCViewsJump=false}
				SetState {Idle}
~~ }


STATE: {ShowNavto} ~~ {

	~~ Show Navto view
	IF: All
			Not Expr {uiviewvisible[Navto]}
			Not Expr {uiviewvisible[Recalls]}
			Not Expr {uiviewvisible[Empyrean]}
			Not Expr {uiviewvisible[Subway]}
			Not Expr {uiviewvisible[JungleSubway]}
			Not Expr {uiviewvisible[Quests]}
		DO: DoAll
				CreateView {Navto} {:CheCommand-TownNetwork.xml}
				DoExpr {uisetlabel[uigetcontrol[Main, ShowNavto], `Navto <<`]}
				SetState {Idle}

	~~ Close Navto view
	IF: Any
			Expr {uiviewvisible[Navto]}
			Expr {uiviewvisible[Recalls]}
			Expr {uiviewvisible[Empyrean]}
			Expr {uiviewvisible[Subway]}
			Expr {uiviewvisible[JungleSubway]}
			Expr {uiviewvisible[Quests]}
		DO: DoAll
				DestroyView {Navto}
				DestroyView {Recalls}
				DestroyView {Empyrean}
				DestroyView {Subway}
				DestroyView {JungleSubway}
				DestroyView {Quests}
				DoExpr {uisetlabel[uigetcontrol[Main, ShowNavto], `Navto >>`]}
				SetState {Idle}


~~ }


STATE: {ShowRecalls} ~~ {

	~~ Show Recalls view
	IF: Not Expr {uiviewvisible[Recalls]}
		DO: DoAll
				DestroyView {Navto}
				CreateView {Recalls} {:CheCommand-Recalls.xml}
				~~ DoExpr {uisetlabel[uigetcontrol[Main, ShowNavto], `Navto <<`]}
				SetState {Idle}

	~~ Close Recalls view
	IF: Expr {uiviewvisible[Recalls]}
		DO: DoAll
				DestroyView {Recalls}
				~~ DoExpr {uisetlabel[uigetcontrol[Main, ShowNavto], `Navto >>`]}
				SetState {Idle}

~~ }


STATE: {ShowEmpyreanPortalspaceActivator} ~~ {

	~~ Show Empyrean Portalspace Activator view
	IF: Not Expr {uiviewvisible[Empyrean]}
		DO: DoAll
				DestroyView {Navto}
				CreateView {Empyrean} {:CheCommand-Empyrean.xml}
				SetState {Idle}

	~~ Close Empyrean Portalspace Activator view
	IF: Expr {uiviewvisible[Empyrean]}
		DO: DoAll
				DestroyView {Empyrean}
				SetState {Idle}

~~ }


STATE: {ShowSubway} ~~ {

	~~ Show Subway view
	IF: Not Expr {uiviewvisible[Subway]}
		DO: DoAll
				DestroyView {Navto}
				CreateView {Subway} {:CheCommand-Subway.xml}
				SetState {Idle}

	~~ Close Empyrean Portalspace Activator view
	IF: Expr {uiviewvisible[Subway]}
		DO: DoAll
				DestroyView {Subway}
				SetState {Idle}

~~ }


STATE: {ShowJungleSubway} ~~ {

	~~ Show Subway view
	IF: Not Expr {uiviewvisible[JungleSubway]}
		DO: DoAll
				DestroyView {Navto}
				CreateView {JungleSubway} {:CheCommand-JungleSubway.xml}
				SetState {Idle}

	~~ Close Empyrean Portalspace Activator view
	IF: Expr {uiviewvisible[JungleSubway]}
		DO: DoAll
				DestroyView {JungleSubway}
				SetState {Idle}

~~ }


STATE: {ShowQuests} ~~ {

	~~ Show Quests view
	IF: Not Expr {uiviewvisible[Quests]}
		DO: DoAll
				DestroyView {Navto}
				CreateView {Quests} {:CheCommand-Quests.xml}
				SetState {Idle}

	~~ Close Quests view
	IF: Expr {uiviewvisible[Quests]}
		DO: DoAll
				DestroyView {Quests}
				SetState {Idle}

~~ }


STATE: {ShowKilltasks} ~~ {

	~~ Show Killtasks view
	IF: Not Expr {uiviewvisible[Killtasks]}
		DO: DoAll
				DestroyView {Navto}
				CreateView {Killtasks} {:CheCommand-Killtasks.xml}
				SetState {Idle}

	~~ Close Killtasks view
	IF: Expr {uiviewvisible[Killtasks]}
		DO: DoAll
				DestroyView {Killtasks}
				SetState {Idle}

~~ }


STATE: {ShowActions} ~~ {

	~~ Show Actions view
	IF: Not Expr {uiviewvisible[Actions]}
		DO: DoAll
				CreateView {Actions} {:CheCommand-Actions.xml}
				DoExpr {uisetlabel[uigetcontrol[Main, ShowActions], `Actions <<`]}
				DoExpr {@CCViewsActions=true}
				SetState {Idle}

	~~ Close Action view
	IF: Expr {uiviewvisible[Actions]}
		DO: DoAll
				DestroyView {Actions}
				DoExpr {uisetlabel[uigetcontrol[Main, ShowActions], `Actions >>`]}
				DoExpr {@CCViewsActions=false}
				SetState {Idle}

~~ }


STATE: {PickupSelect} ~~ {

	~~ Issue the `#pickup` commmand for the selected item
	IF: Always
		DO: DoAll
				DoExpr {$item=wobjectgetname[wobjectgetselection[]]}
				DoExpr {$command=`#pickup `+$item}
				DoExpr {clearvar[item]}
				SetState {ChatCommand}

~~ }


STATE: {CountSelect} ~~ {

	~~ Issue the `#count` commmand for the selected item
	IF: Always
		DO: DoAll
				DoExpr {$item=wobjectgetname[wobjectgetselection[]]}
				DoExpr {$command=`#count `+$item}
				DoExpr {clearvar[item]}
				SetState {ChatCommand}

~~ }


STATE: {UseSelect} ~~ {

	~~ Issue the `#use` commmand for the selected item
	IF: Always
		DO: DoAll
				DoExpr {$item=wobjectgetname[wobjectgetselection[]]}
				DoExpr {$command=`#use `+$item}
				DoExpr {clearvar[item]}
				SetState {ChatCommand}

~~ }


STATE: {LootSelect} ~~ {

	~~ Warn if no container open
	IF: Expr {wobjectgetopencontainer[]==false}
		DO: DoAll
				DoExpr {echo[`[WARN] No corpse or container open!`, $COLOR_WARN]}
				SetState {Idle}

	~~ Issue the `#loot` command for the selected item in the selected corpse
	IF: Always
		DO: DoAll
				DoExpr {$item=wobjectgetname[wobjectgetselection[]]}
				DoExpr {$corpse=wobjectgetname[wobjectgetopencontainer[]]}
				DoExpr {$command=`#loot `+$item+` from `+$corpse}
				DoExpr {listmap[listcreate[`item`, `corpse`], `clearvar[$1]`]}
				SetState {ChatCommand}

~~ }


STATE: {GiveSelect} ~~ {

	~~ Display the Give Selection view
	IF: Always
		DO: DoAll
				CreateView {GiveSelect} {:CheCommand-GiveSelect.xml}
				DoExpr {$item=wobjectgetname[wobjectgetselection[]]}
				DoExpr {uisetlabel[uigetcontrol[GiveSelect, Item], $item]}
				SetState {Idle}

~~ }


STATE: {SetGiveItem} ~~ {

	IF: Always
		DO: DoAll
				DoExpr {$item=wobjectgetname[wobjectgetselection[]]}
				DoExpr {uisetlabel[uigetcontrol[GiveSelect, Item], $item]}
				SetState {Idle}

~~ }


STATE: {SetGiveRecipient} ~~ {

	IF: Always
		DO: DoAll
				DoExpr {$recipient=wobjectgetname[wobjectgetselection[]]}
				DoExpr {uisetlabel[uigetcontrol[GiveSelect, Recipient], $recipient]}
				SetState {Idle}

~~ }


STATE: {GiveSelectComplete} ~~ {

	~~ Issue the `#give` command for the selected item only
	IF: Expr {testvar[recipient]==false}
		DO: DoAll
				DoExpr {$command=`#give `+$item}
				DoExpr {listmap[listcreate[`item`, `recipient`], `clearvar[$1]`]}
				DestroyView {GiveSelect}
				SetState {ChatCommand}

	~~ Issue the `#give` command for the selected item and the selected recipient
	IF: Always
		DO: DoAll
				DoExpr {$command=`#give `+$item+` to `+$recipient}
				DoExpr {listmap[listcreate[`item`, `recipient`], `clearvar[$1]`]}
				DestroyView {GiveSelect}
				SetState {ChatCommand}

~~ }


STATE: {ShowSettings} ~~ {

	~~ Show Settings view
	IF: Not Expr {uiviewvisible[Settings]}
		DO: DoAll
				CreateView {Settings} {:CheCommand-Settings.xml}
				DoExpr {uisetlabel[uigetcontrol[Main, ShowSettings], `Settings <<`]}
				DoExpr {uisetlabel[uigetcontrol[Settings, ChatCommand], `Chat: `+@CCChatCommand]}  ~~ Set the current ChatCommand
				SetState {Idle}

	~~ Close Settings view
	IF: Expr {uiviewvisible[Settings]}
		DO: DoAll
				DestroyView {Settings}
				DoExpr {uisetlabel[uigetcontrol[Main, ShowSettings], `Settings >>`]}
				SetState {Idle}

~~ }


STATE: {SetupViews} ~~ {

	IF: Always
		DO: DoAll
				DoExpr {uisetlabel[uigetcontrol[Main, Follow], ifthen[@CCStay, `Follow`, `Stay`]]}
				~~ DoExpr {uisetlabel[uigetcontrol[Main, Combat], ifthen[testpvar[CCOriginalVitalsEnableCombat], `ifthen[@CCOriginalVitalsEnableCombat, \`Combat Off\`, \`Combat On\`]`, `ifthen[vtgetsetting[EnableCombat], \`Combat Off\`, \`Combat On\`]`]]}

	~~ If actions was previously open show it again
	IF: Expr {@CCViewsActions==true}
		DO: DoAll
				CreateView {Actions} {:CheCommand-Actions.xml}
				DoExpr {uisetlabel[uigetcontrol[Main, ShowActions], `Actions <<`]}

	~~ If jump was previously open show it again
	IF: Expr {@CCViewsJump==true}
		DO: DoAll
				CreateView {Jump} {:CheCommand-Jump.xml}
				DoExpr {uisetlabel[uigetcontrol[Main, ShowJump], `Jump <<`]}

	~~ If timer is running open timer view
	IF: Expr {testvar[CCTimer]==true}
		DO: CreateView {Timer} {:CheCommand-Timer.xml}

	IF: Always
		DO: SetState {Idle}

~~ }


STATE: {ShowMetas} ~~ {

	~~ Close the settings view
	IF: Always
		DO: DoAll
				DoExpr {uisetlabel[uigetcontrol[Main, ShowSettings], `Settings >>`]}
				DestroyView {Settings}

	~~ Open the Metas view
	IF: Always
		DO: DoAll
				DoExpr {$MetaOffset=0}
				CreateView {Metas} {:CheCommand-Metas.xml}
				SetState {SetMetas}

~~ }


STATE: {SetMetas} ~~ {

	~~ Show all buttons
	IF: Always
		DO: DoAll
				DoExpr {uisetvisible[uigetcontrol[Metas, btnMeta1], 1]}
				DoExpr {uisetvisible[uigetcontrol[Metas, btnMeta2], 1]}
				DoExpr {uisetvisible[uigetcontrol[Metas, btnMeta3], 1]}
				DoExpr {uisetvisible[uigetcontrol[Metas, btnMeta4], 1]}
				DoExpr {uisetvisible[uigetcontrol[Metas, btnMeta5], 1]}
				DoExpr {uisetvisible[uigetcontrol[Metas, btnMeta6], 1]}
				DoExpr {uisetvisible[uigetcontrol[Metas, btnMeta7], 1]}
				DoExpr {uisetvisible[uigetcontrol[Metas, btnMeta8], 1]}
				DoExpr {uisetvisible[uigetcontrol[Metas, btnMeta9], 1]}

				DoExpr {uisetvisible[uigetcontrol[Metas, btnNext], 1]}
				DoExpr {uisetvisible[uigetcontrol[Metas, btnPrevious], 1]}

	~~ Set all the buttons with the names of the metas
	IF: Always
		DO: DoAll
				DoExpr {uisetlabel[uigetcontrol[Metas, btnMeta1], ifthen[listcount[@CCMetaKeys]>=1+$MetaOffset, `@CCMetaKeys{{0+$MetaOffset}}`, `empty`]]}
				DoExpr {uisetlabel[uigetcontrol[Metas, btnMeta2], ifthen[listcount[@CCMetaKeys]>=2+$MetaOffset, `@CCMetaKeys{{1+$MetaOffset}}`, `empty`]]}
				DoExpr {uisetlabel[uigetcontrol[Metas, btnMeta3], ifthen[listcount[@CCMetaKeys]>=3+$MetaOffset, `@CCMetaKeys{{2+$MetaOffset}}`, `empty`]]}
				DoExpr {uisetlabel[uigetcontrol[Metas, btnMeta4], ifthen[listcount[@CCMetaKeys]>=4+$MetaOffset, `@CCMetaKeys{{3+$MetaOffset}}`, `empty`]]}
				DoExpr {uisetlabel[uigetcontrol[Metas, btnMeta5], ifthen[listcount[@CCMetaKeys]>=5+$MetaOffset, `@CCMetaKeys{{4+$MetaOffset}}`, `empty`]]}
				DoExpr {uisetlabel[uigetcontrol[Metas, btnMeta6], ifthen[listcount[@CCMetaKeys]>=6+$MetaOffset, `@CCMetaKeys{{5+$MetaOffset}}`, `empty`]]}
				DoExpr {uisetlabel[uigetcontrol[Metas, btnMeta7], ifthen[listcount[@CCMetaKeys]>=7+$MetaOffset, `@CCMetaKeys{{6+$MetaOffset}}`, `empty`]]}
				DoExpr {uisetlabel[uigetcontrol[Metas, btnMeta8], ifthen[listcount[@CCMetaKeys]>=8+$MetaOffset, `@CCMetaKeys{{7+$MetaOffset}}`, `empty`]]}
				DoExpr {uisetlabel[uigetcontrol[Metas, btnMeta9], ifthen[listcount[@CCMetaKeys]>=9+$MetaOffset, `@CCMetaKeys{{8+$MetaOffset}}`, `empty`]]}

	~~ Hide the empty buttons
	IF: Always
		DO: DoAll
				DoExpr {ifthen[listcount[@CCMetaKeys]>=1+$MetaOffset, `false`, `uisetvisible[uigetcontrol[Metas, btnMeta1], 0]`]}
				DoExpr {ifthen[listcount[@CCMetaKeys]>=2+$MetaOffset, `false`, `uisetvisible[uigetcontrol[Metas, btnMeta2], 0]`]}
				DoExpr {ifthen[listcount[@CCMetaKeys]>=3+$MetaOffset, `false`, `uisetvisible[uigetcontrol[Metas, btnMeta3], 0]`]}
				DoExpr {ifthen[listcount[@CCMetaKeys]>=4+$MetaOffset, `false`, `uisetvisible[uigetcontrol[Metas, btnMeta4], 0]`]}
				DoExpr {ifthen[listcount[@CCMetaKeys]>=5+$MetaOffset, `false`, `uisetvisible[uigetcontrol[Metas, btnMeta5], 0]`]}
				DoExpr {ifthen[listcount[@CCMetaKeys]>=6+$MetaOffset, `false`, `uisetvisible[uigetcontrol[Metas, btnMeta6], 0]`]}
				DoExpr {ifthen[listcount[@CCMetaKeys]>=7+$MetaOffset, `false`, `uisetvisible[uigetcontrol[Metas, btnMeta7], 0]`]}
				DoExpr {ifthen[listcount[@CCMetaKeys]>=8+$MetaOffset, `false`, `uisetvisible[uigetcontrol[Metas, btnMeta8], 0]`]}
				DoExpr {ifthen[listcount[@CCMetaKeys]>=9+$MetaOffset, `false`, `uisetvisible[uigetcontrol[Metas, btnMeta9], 0]`]}

	~~ Hide the Previous button if you can't go back
	IF: Expr {$MetaOffset<=0}
		DO: DoExpr {uisetvisible[uigetcontrol[Metas, btnPrevious], 0]}

	~~ Hide the Next button if you can't go foward
	IF: Expr {listcount[@CCMetaKeys]<=9+$MetaOffset}
		DO: DoExpr {uisetvisible[uigetcontrol[Metas, btnNext], 0]}

	~~ Return to Idle
	IF: Always
		DO: SetState {Idle}

~~ }


STATE: {MetaNextPage} ~~ {

	~~ Increment to the next page
	IF: Always
		DO: DoAll
				DoExpr {$MetaOffset=$MetaOffset+9}
				SetState {SetMetas}

~~ }


STATE: {MetaPreviousPage} ~~ {

	~~ Don't go into a negative offset
	IF: Expr {$MetaOffset<=0}
		DO: SetState {SetMetas}

	~~ Decrement to the previous page
	IF: Always
		DO: DoAll
				DoExpr {$MetaOffset=$MetaOffset-9}
				SetState {SetMetas}
~~ }


STATE: {ShowProfiles} ~~ {

	~~ Close the settings view
	IF: Always
		DO: DoAll
				DoExpr {uisetlabel[uigetcontrol[Main, ShowSettings], `Settings >>`]}
				DestroyView {Settings}

	~~ Open the Profiles view
	IF: Always
		DO: DoAll
				DoExpr {$ProfileOffset=0}
				CreateView {Profiles} {:CheCommand-Profiles.xml}
				SetState {SetProfiles}

~~ }


STATE: {SetProfiles} ~~ {

	~~ Show all buttons
	IF: Always
		DO: DoAll
				DoExpr {uisetvisible[uigetcontrol[Profiles, btnProfile1], 1]}
				DoExpr {uisetvisible[uigetcontrol[Profiles, btnProfile2], 1]}
				DoExpr {uisetvisible[uigetcontrol[Profiles, btnProfile3], 1]}
				DoExpr {uisetvisible[uigetcontrol[Profiles, btnProfile4], 1]}
				DoExpr {uisetvisible[uigetcontrol[Profiles, btnProfile5], 1]}
				DoExpr {uisetvisible[uigetcontrol[Profiles, btnProfile6], 1]}
				DoExpr {uisetvisible[uigetcontrol[Profiles, btnProfile7], 1]}
				DoExpr {uisetvisible[uigetcontrol[Profiles, btnProfile8], 1]}
				DoExpr {uisetvisible[uigetcontrol[Profiles, btnProfile9], 1]}

				DoExpr {uisetvisible[uigetcontrol[Profiles, btnNext], 1]}
				DoExpr {uisetvisible[uigetcontrol[Profiles, btnPrevious], 1]}

	~~ Set all the buttons with the names of the profiles
	IF: Always
		DO: DoAll
				DoExpr {uisetlabel[uigetcontrol[Profiles, btnProfile1], ifthen[listcount[@CCProfileKeys]>=1+$ProfileOffset, `@CCProfileKeys{{0+$ProfileOffset}}`, `empty`]]}
				DoExpr {uisetlabel[uigetcontrol[Profiles, btnProfile2], ifthen[listcount[@CCProfileKeys]>=2+$ProfileOffset, `@CCProfileKeys{{1+$ProfileOffset}}`, `empty`]]}
				DoExpr {uisetlabel[uigetcontrol[Profiles, btnProfile3], ifthen[listcount[@CCProfileKeys]>=3+$ProfileOffset, `@CCProfileKeys{{2+$ProfileOffset}}`, `empty`]]}
				DoExpr {uisetlabel[uigetcontrol[Profiles, btnProfile4], ifthen[listcount[@CCProfileKeys]>=4+$ProfileOffset, `@CCProfileKeys{{3+$ProfileOffset}}`, `empty`]]}
				DoExpr {uisetlabel[uigetcontrol[Profiles, btnProfile5], ifthen[listcount[@CCProfileKeys]>=5+$ProfileOffset, `@CCProfileKeys{{4+$ProfileOffset}}`, `empty`]]}
				DoExpr {uisetlabel[uigetcontrol[Profiles, btnProfile6], ifthen[listcount[@CCProfileKeys]>=6+$ProfileOffset, `@CCProfileKeys{{5+$ProfileOffset}}`, `empty`]]}
				DoExpr {uisetlabel[uigetcontrol[Profiles, btnProfile7], ifthen[listcount[@CCProfileKeys]>=7+$ProfileOffset, `@CCProfileKeys{{6+$ProfileOffset}}`, `empty`]]}
				DoExpr {uisetlabel[uigetcontrol[Profiles, btnProfile8], ifthen[listcount[@CCProfileKeys]>=8+$ProfileOffset, `@CCProfileKeys{{7+$ProfileOffset}}`, `empty`]]}
				DoExpr {uisetlabel[uigetcontrol[Profiles, btnProfile9], ifthen[listcount[@CCProfileKeys]>=9+$ProfileOffset, `@CCProfileKeys{{8+$ProfileOffset}}`, `empty`]]}

	~~ Hide the empty buttons
	IF: Always
		DO: DoAll
				DoExpr {ifthen[listcount[@CCProfileKeys]>=1+$ProfileOffset, `false`, `uisetvisible[uigetcontrol[Profiles, btnProfile1], 0]`]}
				DoExpr {ifthen[listcount[@CCProfileKeys]>=2+$ProfileOffset, `false`, `uisetvisible[uigetcontrol[Profiles, btnProfile2], 0]`]}
				DoExpr {ifthen[listcount[@CCProfileKeys]>=3+$ProfileOffset, `false`, `uisetvisible[uigetcontrol[Profiles, btnProfile3], 0]`]}
				DoExpr {ifthen[listcount[@CCProfileKeys]>=4+$ProfileOffset, `false`, `uisetvisible[uigetcontrol[Profiles, btnProfile4], 0]`]}
				DoExpr {ifthen[listcount[@CCProfileKeys]>=5+$ProfileOffset, `false`, `uisetvisible[uigetcontrol[Profiles, btnProfile5], 0]`]}
				DoExpr {ifthen[listcount[@CCProfileKeys]>=6+$ProfileOffset, `false`, `uisetvisible[uigetcontrol[Profiles, btnProfile6], 0]`]}
				DoExpr {ifthen[listcount[@CCProfileKeys]>=7+$ProfileOffset, `false`, `uisetvisible[uigetcontrol[Profiles, btnProfile7], 0]`]}
				DoExpr {ifthen[listcount[@CCProfileKeys]>=8+$ProfileOffset, `false`, `uisetvisible[uigetcontrol[Profiles, btnProfile8], 0]`]}
				DoExpr {ifthen[listcount[@CCProfileKeys]>=9+$ProfileOffset, `false`, `uisetvisible[uigetcontrol[Profiles, btnProfile9], 0]`]}

	~~ Hide the Previous button if you can't go back
	IF: Expr {$ProfileOffset<=0}
		DO: DoExpr {uisetvisible[uigetcontrol[Profiles, btnPrevious], 0]}

	~~ Hide the Next button if you can't go foward
	IF: Expr {listcount[@CCProfileKeys]<=9+$ProfileOffset}
		DO: DoExpr {uisetvisible[uigetcontrol[Profiles, btnNext], 0]}

	~~ Return to Idle
	IF: Always
		DO: SetState {Idle}

~~ }


STATE: {ProfileNextPage} ~~ {

	~~ Increment to the next page
	IF: Always
		DO: DoAll
				DoExpr {$ProfileOffset=$ProfileOffset+9}
				SetState {SetProfiles}

~~ }


STATE: {ProfilePreviousPage} ~~ {

	~~ Don't go into a negative offset
	IF: Expr {$ProfileOffset<=0}
		DO: SetState {SetProfiles}

	~~ Decrement to the previous page
	IF: Always
		DO: DoAll
				DoExpr {$ProfileOffset=$ProfileOffset-9}
				SetState {SetProfiles}
~~ }


STATE: {ToggleStay} ~~ {

	IF: Expr {@CCStay==true}
		DO: DoAll
				DoExpr {uisetlabel[uigetcontrol[Main, Follow], `Stay`]}
				DoExpr {$command=`#action follow`}
				SetState {ChatCommand}

	IF: Expr {@CCStay==false}
		DO: DoAll
				DoExpr {uisetlabel[uigetcontrol[Main, Follow], `Follow`]}
				DoExpr {$command=`#action stay`}
				SetState {ChatCommand}

~~ }


STATE: {ToggleChatCommand} ~~ {

	~~ Toggle ChatCommand to say
	IF: Expr {@CCChatCommand==`Fellow`}
		DO: DoAll
				DoExpr {setpvar[CCChatCommand, `Say`]}
				DoExpr {uisetlabel[uigetcontrol[Settings, ChatCommand], `Chat: Say`]}
				SetState {Idle}

	~~ Toggle ChatCommand to fellow
	IF: Expr {@CCChatCommand==`Say`}
		DO: DoAll
				DoExpr {setpvar[CCChatCommand, `Fellow`]}
				DoExpr {uisetlabel[uigetcontrol[Settings, ChatCommand], `Chat: Fellow`]}
				SetState {Idle}

~~ }


STATE: {ChatCommand} ~~ {

	~~ Warn if sending chat commands to Fellow and not in a fellow
	IF: All
			Expr {@CCChatCommand==`Fellow`}
			Expr {getfellowshipstatus[]!=1}
		DO: DoAll
				DoExpr {echo[`[WARN] Not in fellow but sending commands to fellow!`, $COLOR_WARN]}
				SetState {Idle}

	~~ Send chat command
	IF: Always
		DO: DoAll
				ChatExpr {`/`+@CCChatCommand+` `+$command}
				DoExpr {clearvar[command]}
				SetState {Idle}


~~ }


~~ STATE: {ToggleCombat} ~~ {

~~ 	IF: Expr {ifthen[testpvar[CCOriginalVitalsEnableCombat], `@CCOriginalVitalsEnableCombat`, `vtgetsetting[EnableCombat]`]==true}
~~ 		DO: DoAll
~~ 				ChatExpr {`#vtoption enablecombat false`}
~~ 				DoExpr {uisetlabel[uigetcontrol[Main, Combat], `Combat On`]}
~~ 				SetState {Idle}

~~ 	IF: Expr {ifthen[testpvar[CCOriginalVitalsEnableCombat], `@CCOriginalVitalsEnableCombat`, `vtgetsetting[EnableCombat]`]==false}
~~ 		DO: DoAll
~~ 				ChatExpr {`#vtoption enablecombat true`}
~~ 				DoExpr {uisetlabel[uigetcontrol[Main, Combat], `Combat Off`]}
~~ 				SetState {Idle}

~~ ~~ }

STATE: {ToggleVitals} ~~ {

	IF: Expr {@CCVitals==true}
		DO: DoAll
				DoExpr {@CCVitals=false} ~~ Toggle vitals
				DoExpr {setpvar[CCOriginalVitalsEnableBuffing, cstr[vtgetsetting[EnableBuffing]]]}
				DoExpr {setpvar[CCOriginalVitalsEnableCombat, cstr[vtgetsetting[EnableCombat]]]}
				DoExpr {setpvar[CCOriginalVitalsEnableLooting, cstr[vtgetsetting[EnableLooting]]]}
				DoExpr {setpvar[CCOriginalVitalsRechargeNormHitP, cstr[vtgetsetting[Recharge-Norm-HitP]]]}
				DoExpr {setpvar[CCOriginalVitalsRechargeNormStam, cstr[vtgetsetting[Recharge-Norm-Stam]]]}
				DoExpr {setpvar[CCOriginalVitalsRechargeNormMana, cstr[vtgetsetting[Recharge-Norm-Mana]]]}
				DoExpr {setpvar[CCOriginalVitalsRechargeNoTargHitP, cstr[vtgetsetting[Recharge-NoTarg-HitP]]]}
				DoExpr {setpvar[CCOriginalVitalsRechargeNoTargStam, cstr[vtgetsetting[Recharge-NoTarg-Stam]]]}
				DoExpr {setpvar[CCOriginalVitalsRechargeNoTargMana, cstr[vtgetsetting[Recharge-NoTarg-Mana]]]}
				DoExpr {setpvar[CCOriginalVitalsRechargeHelperHitP, cstr[vtgetsetting[Recharge-Helper-HitP]]]}
				DoExpr {setpvar[CCOriginalVitalsRechargeHelperStam, cstr[vtgetsetting[Recharge-Helper-Stam]]]}
				DoExpr {setpvar[CCOriginalVitalsRechargeHelperMana, cstr[vtgetsetting[Recharge-Helper-Mana]]]}
				DoExpr {vtsetsetting[EnableBuffing, `0`]}
				DoExpr {vtsetsetting[EnableCombat, `0`]}
				DoExpr {vtsetsetting[EnableLooting, `0`]}
				DoExpr {vtsetsetting[Recharge-Norm-HitP, `0`]}
				DoExpr {vtsetsetting[Recharge-Norm-Stam, `0`]}
				DoExpr {vtsetsetting[Recharge-Norm-Mana, `0`]}
				DoExpr {vtsetsetting[Recharge-NoTarg-HitP, `0`]}
				DoExpr {vtsetsetting[Recharge-NoTarg-Stam, `0`]}
				DoExpr {vtsetsetting[Recharge-NoTarg-Mana, `0`]}
				DoExpr {vtsetsetting[Recharge-Helper-HitP, `0`]}
				DoExpr {vtsetsetting[Recharge-Helper-Stam, `0`]}
				DoExpr {vtsetsetting[Recharge-Helper-Mana, `0`]}
				Return

	IF: Expr {@CCVitals==false}
		DO: DoAll
				DoExpr {@CCVitals=true} ~~ Toggle vitals
				DoExpr {vtsetsetting[EnableBuffing, @CCOriginalVitalsEnableBuffing]}
				DoExpr {vtsetsetting[EnableCombat, @CCOriginalVitalsEnableCombat]}
				DoExpr {vtsetsetting[EnableLooting, @CCOriginalVitalsEnableLooting]}
				DoExpr {vtsetsetting[Recharge-Norm-HitP, @CCOriginalVitalsRechargeNormHitP]}
				DoExpr {vtsetsetting[Recharge-Norm-Stam, @CCOriginalVitalsRechargeNormStam]}
				DoExpr {vtsetsetting[Recharge-Norm-Mana, @CCOriginalVitalsRechargeNormMana]}
				DoExpr {vtsetsetting[Recharge-NoTarg-HitP, @CCOriginalVitalsRechargeNoTargHitP]}
				DoExpr {vtsetsetting[Recharge-NoTarg-Stam, @CCOriginalVitalsRechargeNoTargStam]}
				DoExpr {vtsetsetting[Recharge-NoTarg-Mana, @CCOriginalVitalsRechargeNoTargMana]}
				DoExpr {vtsetsetting[Recharge-Helper-HitP, @CCOriginalVitalsRechargeHelperHitP]}
				DoExpr {vtsetsetting[Recharge-Helper-Stam, @CCOriginalVitalsRechargeHelperStam]}
				DoExpr {vtsetsetting[Recharge-Helper-Mana, @CCOriginalVitalsRechargeHelperMana]}
				Return

~~ }


~~ Use Virindi Hotkey System to map this state to a key like `tab` to toggle on and off combat/healing/buffing
STATE: {HotkeyToggleVitals} ~~ {

	IF: Expr {@CCVitals==true}
		DO: DoAll
				DoExpr {ifthen[$LEVEL_INFO>=@CCDebug, `echo[\`[INFO] Turning off vitals\`, $COLOR_INFO]`, `false`]}
				CallState {ToggleVitals} {Idle}

	IF: Expr {@CCVitals==false}
		DO: DoAll
				DoExpr {ifthen[$LEVEL_INFO>=@CCDebug, `echo[\`[INFO] Turning on vitals\`, $COLOR_INFO]`, `false`]}
				CallState {ToggleVitals} {Idle}

	IF: Always
		DO: SetState {Idle}
~~ }

NAV: Empty once ~~ {
~~